# LeetCode 2000~3000

## 2131. Longest Palindrome by Concatenating Two Letter Words

> :orange_circle:

给一串单词，每个单词由两个小写字母构成，从中选取任意单词并任意顺序相连，求能得到的最长的回文串的长度。每个单词最多选择一次，若不能构成回文串，返回0

### 方法

- 类似Two Sum的思想，采用Hash table记录出现过的单词及次数。T: O(n), S: O(n)
- 当遇到一个单词时，且其反转的单词也存在，则回文串长度加4。注意`cl, lc, gg, gg`都包含在此种情况内
- 最后查看是否有剩余的两个字母相同的单词，如`gg`，可以放置在回文串在最中间，且只能放置一个
- 可以不采用哈希表，而使用数组哈希`count[26][26]`记录每个单词出现次数

```cpp
class Solution {
public:
    int longestPalindrome(vector<string>& words) {
        int res = 0;
        unordered_map<string, int> map;
        for (int i = 0; i < words.size(); i++) {
            string str = words[i].substr(1, 1) + words[i].substr(0, 1);
            if (map.find(str) != map.end() && map[str] > 0) {
                map[str]--;
                res += 4;
            } else {
                map[words[i]]++;
            }
        }
        for (auto key : map) {
            if (key.first[0] == key.first[1] && key.second > 0) {
                res += 2;
                break;
            }
        }
        return res;
    }
};
```

