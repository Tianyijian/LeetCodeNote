# LeetCode 2000~3000

## 2131. Longest Palindrome by Concatenating Two Letter Words

> :orange_circle:

给一串单词，每个单词由两个小写字母构成，从中选取任意单词并任意顺序相连，求能得到的最长的回文串的长度。每个单词最多选择一次，若不能构成回文串，返回0

### 方法

- 类似Two Sum的思想，采用Hash table记录出现过的单词及次数。T: O(n), S: O(n)
- 当遇到一个单词时，且其反转的单词也存在，则回文串长度加4。注意`cl, lc, gg, gg`都包含在此种情况内
- 最后查看是否有剩余的两个字母相同的单词，如`gg`，可以放置在回文串在最中间，且只能放置一个
- 可以不采用哈希表，而使用数组哈希`count[26][26]`记录每个单词出现次数

```cpp
class Solution {
public:
    int longestPalindrome(vector<string>& words) {
        int res = 0;
        unordered_map<string, int> map;
        for (int i = 0; i < words.size(); i++) {
            string str = words[i].substr(1, 1) + words[i].substr(0, 1);
            if (map.find(str) != map.end() && map[str] > 0) {
                map[str]--;
                res += 4;
            } else {
                map[words[i]]++;
            }
        }
        for (auto key : map) {
            if (key.first[0] == key.first[1] && key.second > 0) {
                res += 2;
                break;
            }
        }
        return res;
    }
};
```

## 2225. Find Players With Zero or One Losses

> :orange_circle:

整数数组 `matches` 记录比赛的结果 `matches[i] = [winneri, loseri]` ，找出其中没有输过比赛的选手，以及只输一场的选手

### 方法一

- 哈希map，记录赢者以及输者输的场次，最后遍历map即可。可直接采用有序map，或者最后再排序。T: O(nlogn), S: O(n)

```cpp
class Solution {
public:
    vector<vector<int>> findWinners(vector<vector<int>>& matches) {
        map<int, int> loseCount;
        for (int i = 0; i < matches.size(); i++) {
            int winner = matches[i][0], loser = matches[i][1];
            if (loseCount.find(winner) == loseCount.end()) {
                loseCount[winner] = 0;
            }
            loseCount[loser]++;
        }
        vector<vector<int>> res(2);
        for (auto& [k, v] : loseCount) {
            if (v == 0) res[0].push_back(k);
            else if (v == 1) res[1].push_back(k);
        }
        return res;
    }
};
```

### 方法二

- Counting sort，用数组记录每位选手的输赢状态，最后遍历数组即可，可以避免排序。T: O(n + k), S: O(k)
- -1代表没有比赛，0代表比赛至少一场且全赢，1代表输了1场，>1代表输了多场

```cpp
class Solution {
public:
    vector<vector<int>> findWinners(vector<vector<int>>& matches) {
        vector<int> loseCount(100001, -1);
        for (int i = 0; i < matches.size(); i++) {
            int winner = matches[i][0], loser = matches[i][1];
            if (loseCount[winner] == -1) {
                loseCount[winner] = 0;
            }
            if (loseCount[loser] == -1) {
                loseCount[loser] = 1;
            } else loseCount[loser]++;
        }
        vector<vector<int>> res(2);
        for (int i = 0; i < loseCount.size(); i++) {
            if (loseCount[i] == 0) res[0].push_back(i);
            else if (loseCount[i] == 1) res[1].push_back(i);
        }
        return res;
    }
};
```

## 2256. Minimum Average Difference

> :orange_ciecle:

给一个长度为n下标从0开始的整数数组，下标`i`的平均差是前`i+1`个元素的平均值与后`n-i-1`个元素的平均值的差的绝对值。返回最小平均差的下标，如果有多个，返回最小的一个.平均值向下取整，0个元素平均值为0

`1 <= nums.length <= 10^5`, `0 <= nums[i] <= 10^5`

### 方法

- 遍历得到总和，从左到右遍历记录左侧和，相减可得到右侧和。T: O(n), S: O(1)

```cpp
class Solution {
public:
    int minimumAverageDifference(vector<int>& nums) {
        long long sum = 0;
        for (int i : nums) sum += i;
        int minRes = INT_MAX;
        int ans = -1;
        long long leftSum = 0;
        int n = nums.size();
        for (int i = 0; i < n; i++) {
            leftSum += nums[i];
            sum -= nums[i];
            int rightAvg = i == n - 1 ? 0 : sum / (n - i - 1);
            int val = abs(leftSum / (i + 1) - rightAvg);
            if (val < minRes) {
                minRes = val;
                ans = i;
            }
        }
        return ans;
    }
};
```

