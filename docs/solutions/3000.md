# LeetCode 2000~3000

## 2131. Longest Palindrome by Concatenating Two Letter Words

> :orange_circle:

给一串单词，每个单词由两个小写字母构成，从中选取任意单词并任意顺序相连，求能得到的最长的回文串的长度。每个单词最多选择一次，若不能构成回文串，返回0

### 方法

- 类似Two Sum的思想，采用Hash table记录出现过的单词及次数。T: O(n), S: O(n)
- 当遇到一个单词时，且其反转的单词也存在，则回文串长度加4。注意`cl, lc, gg, gg`都包含在此种情况内
- 最后查看是否有剩余的两个字母相同的单词，如`gg`，可以放置在回文串在最中间，且只能放置一个
- 可以不采用哈希表，而使用数组哈希`count[26][26]`记录每个单词出现次数

```cpp
class Solution {
public:
    int longestPalindrome(vector<string>& words) {
        int res = 0;
        unordered_map<string, int> map;
        for (int i = 0; i < words.size(); i++) {
            string str = words[i].substr(1, 1) + words[i].substr(0, 1);
            if (map.find(str) != map.end() && map[str] > 0) {
                map[str]--;
                res += 4;
            } else {
                map[words[i]]++;
            }
        }
        for (auto key : map) {
            if (key.first[0] == key.first[1] && key.second > 0) {
                res += 2;
                break;
            }
        }
        return res;
    }
};
```

## 2225. Find Players With Zero or One Losses

> :orange_circle:

整数数组 `matches` 记录比赛的结果 `matches[i] = [winneri, loseri]` ，找出其中没有输过比赛的选手，以及只输一场的选手

### 方法一

- 哈希map，记录赢者以及输者输的场次，最后遍历map即可。可直接采用有序map，或者最后再排序。T: O(nlogn), S: O(n)

```cpp
class Solution {
public:
    vector<vector<int>> findWinners(vector<vector<int>>& matches) {
        map<int, int> loseCount;
        for (int i = 0; i < matches.size(); i++) {
            int winner = matches[i][0], loser = matches[i][1];
            if (loseCount.find(winner) == loseCount.end()) {
                loseCount[winner] = 0;
            }
            loseCount[loser]++;
        }
        vector<vector<int>> res(2);
        for (auto& [k, v] : loseCount) {
            if (v == 0) res[0].push_back(k);
            else if (v == 1) res[1].push_back(k);
        }
        return res;
    }
};
```
