# LeetCode 1000~2000

## 1323. Maximum 69 Number

### 思路

从左到右遍历，第一个6变为9，没有6则不变

### 解法

#### 方法一

直接将数字转为可迭代的字符串。T: O(L), S: O(L)

```cpp
class Solution {
public:
    int maximum69Number (int num) {
        string s = to_string(num);
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == '6') {
                s[i] = '9';
                break;
            }
        }
        return stoi(s);
    }
};
```

#### 方法二

利用数学取余和除10，找到需要更改的位数。T: O(L), S: O(1)

```cpp
class Solution {
public:
    int maximum69Number (int num) {
        int numCopy = num;
        int index = -1;
        int pos = 0;
        while (num) {
            if (num % 10 == 6) index = pos;
            num /= 10;
            pos++;
        }
        return index == -1 ? numCopy : numCopy + 3 * pow(10, index);
    }
};
```



#### 方法三

提取每个位置的数字，存进数组，更改遇到的第一个6。T: O(L), S: O(L)

```cpp
class Solution {
public:
    int maximum69Number (int num) {
        vector<int> number;
        while (num) {
            int a = num % 10;
            number.push_back(a);
            num = num / 10;
        }
        int res = 0;
        bool change = false;
        for (int i = number.size() - 1; i >= 0; i--) {
            if (number[i] == 6 && !change) {
                number[i] = 9;
                change = true;
            }
            res += number[i] * pow(10, i);
        }
        return res;
    }
};
```