# LeetCode 1000~2000

## 1011. Capacity To Ship Packages Within D Days

> :orange_circle:

传送带需要在`days`天内运送包裹，每个包裹有重量。运送包裹要按照顺序，且每天运送重量不超过最大容量。返回可能的最小的容量

### 方法

- 容量最小是包裹重量的最大值，最大是所有包裹的重量和（一天即可运完）。T: O(nlogn), S: O(1)
- 对容量采用二分搜索，判断每个容量是否满足需求，寻找满足要求的最小值

```cpp
class Solution {
public:
    int shipWithinDays(vector<int>& weights, int days) {
        int low = 0, high = 0;
        for (int& w : weights) {
            low = max(low, w);
            high += w;
        }
        while (low < high) {
            int mid = low + (high - low) / 2;
            if (canShip(weights, days, mid)) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high;
    }
private:
    bool canShip(vector<int>& weights, int days, int capacity) {
        int i = 0;
        while (days--) {
            int cur = 0;
            while (cur <= capacity) {
                if (i == weights.size()) return true;
                cur += weights[i++];
            }
            i--;
        }
        return false;
    }
};
```

## 1026. Maximum Difference Between Node and Ancestor

> :orange_circle:

二叉树，找到最大的值 `v = |a.val - b.val|`，a，b是两个不同节点，且a是b的祖先

### 方法

- 暴力搜索：DFS回溯搜索并记录路径值为数组，到达叶节点时，遍历数组得到该路径中的最大差值。T: O(n^2), S: O(n)
- DFS搜索二叉树，记录到某个节点时，祖先中的最大值和最小值，遇到叶节点返回差值，后续遍历返回最大差值。T: O(n), S: O(n)

```cpp
class Solution {
public:
    int maxAncestorDiff(TreeNode* root) {
        return dfs(root, root->val, root->val);
    }
private:
    int dfs(TreeNode* node, int curMax, int curMin) {
        if (node == NULL) {
            return curMax - curMin;
        }
        curMax = max(curMax, node->val);
        curMin = min(curMin, node->val);
        int left = dfs(node->left, curMax, curMin);
        int right = dfs(node->right, curMax, curMin);
        return max(left, right);
    }
};
```

## 1046. Last Stone Weight

> :green_circle:

给一个整数数组，每次选出最大的两个数，如果相等则同时删除，如果不相等则加入其差值。返回最后剩余的数，没有则返回0

### 方法

- 使用最大堆维护数组，每次取出最大的两个数进行操作即可。T: O(nlogn), S: (n)

```cpp
class Solution {
public:
    int lastStoneWeight(vector<int>& stones) {
        priority_queue<int> q(begin(stones), end(stones));
        while (q.size() > 1) {
            int y = q.top(); q.pop();
            int x = q.top(); q.pop();
            if (x < y) q.push(y - x);
        }
        return q.empty() ? 0 : q.top();
    }
};
```

## 1047. Remove All Adjacent Duplicates In String

> :orange_circle:

反复移除字符串中相邻的两个相同字母，返回最终字符串

相似题目：1544. Make The String Great

### 方法

- 可以采用栈的思想进行移除，将字符串视为栈。T: O(n), S: O(n)
- 双指针法进行移除省空间。T: O(n), S: O(1)

```cpp
class Solution {
public:
    string removeDuplicates(string s) {
        int start = 0;
        for (int end = 0; end < s.size(); end++) {
            if (start > 0 && s[end] == s[start - 1]) {
                start--;
            } else s[start++] = s[end];
        }
        return s.substr(0, start);
    }
};
```

## 1137. N-th Tribonacci Number

> :green_circle:

对于n >= 0，T0 = 0, T1 = 1, T2 = 1, Tn+3 = Tn + Tn+1 + Tn+2。给n值，返回Tn

### 方法

- 类似斐波那契数列，简单动态规划。T: O(n), S: O(1)

```cpp
class Solution {
public:
    int tribonacci(int n) {
        if (n == 0) return 0;
        else if (n == 1 || n == 2) return 1;
        int t0 = 0, t1 = 1, t2 = 1, t;
        for (int i = 3; i <= n; i++) {
            t = t0 + t1 + t2;
            t0 = t1;
            t1 = t2;
            t2 = t;
        }
        return t;
    }
};
```

## 1061. Lexicographically Smallest Equivalent String

> :orange_circle:

两个长度相同的字符串表示字符间的等量关系（自反，对称，传递）。依据该等量信息，得到`baseStr`的词典序最小的相等字符串

### 方法

- 并查集，将相等的字符加入同一个集合中，在合并时使用更小的字符代表整个集合。T: O((N+M)log26), S: O(26)

```cpp
class Solution {
public:
    string smallestEquivalentString(string s1, string s2, string baseStr) {
        for (int i = 0; i < 26; i++) parent[i] = i;
        for (int i = 0; i < s1.size(); i++) {
            join(s1[i] - 'a', s2[i] - 'a');
        }
        string ans;
        for (auto& c : baseStr) {
            ans.push_back(find(c - 'a') + 'a');
        }
        return ans;
    }
private: 
    int parent[26];
    int find(int x) {
        return parent[x] == x ? x : parent[x] = find(parent[x]);
    }
    void join(int u, int v) {
        u = find(u);
        v = find(v);
        if (u < v) {
            parent[v] = u;
        } else if (u > v) {
            parent[u] = v;
        }
    }
};
```

## 1071. Greatest Common Divisor of Strings

> :green_circle:

对两个字符串s和t，t能分割s当前仅当s = t + t + t...。给两个字符串，返回能够同时分割这两个字符串的最长字符串

### 方法

- 暴力：从两者中短的字符串或者最大公约数出发，依次递减判断是否能分割两个字符串（长度能整除且多个拼接等于原串）
- 确定存在分割字符串：两个字符串拼接后相同（s1 + s2 == s2 + s1）
- 如果存在分割字符串，则最大分割串的长度一定是两个字符串长度的最大公约数。T: O(m + n), S: O(m + n)

```cpp
class Solution {
public:
    string gcdOfStrings(string str1, string str2) {
        if (str1 + str2 != str2 + str1) {
            return "";
        }
        return str1.substr(0, gcd(str1.size(), str2.size()));
    }
};
```

## 1129. Shortest Path with Alternating Colors

> :orange_circle:

n个节点的有向图，标签从0到n-1，边为红色或蓝色，存在自环或平行边。返回长度为n的数组`answer`，其中`answer[x]`表示节点0到节点x的最短路径的长度，路径为红蓝边交替出现。不存在路径，则返回-1

### 方法

- BFS，从节点0出发，首次到达的每个节点的步数即为最短路径。注意路径红蓝边要交替出现。T: O(n+e), S: O(n+e)
- 使用访问数组记录是否已通过红或蓝边到达某个节点，防止重复访问陷入循环

```cpp
class Solution {
public:
    vector<int> shortestAlternatingPaths(int n, vector<vector<int>>& redEdges, vector<vector<int>>& blueEdges) {
        vector<vector<pair<int, int>>> graph(n);
        for (auto& e : redEdges) {
            graph[e[0]].push_back({e[1], 0});
        }
        for (auto& e : blueEdges) {
            graph[e[0]].push_back({e[1], 1});
        }
        vector<int> ans(n, -1);
        ans[0] = 0;
        vector<vector<bool>> vis(n, vector<bool>(2, false));
        vis[0][0] = vis[0][1] = true;
        queue<pair<int, int>> q;
        q.push({0, -1});
        int step = 1;
        while (!q.empty()) {
            int size = q.size();
            while (size--) {
                auto [node, color] = q.front();
                q.pop();
                for (auto [v, c] : graph[node]) {
                    if (vis[v][c] || color == c) continue;
                    vis[v][c] = true;
                    if (ans[v] == -1) ans[v] = step;
                    q.push({v, c});
                }
            }
            step++;
        }
        return ans;
    }
};
```

## 1162. As Far from Land as Possible

> :orange_circle:

nxn网格仅有0和1，0代表水，1代表陆地。找到一个水单元，其到最近的陆地单元的距离最大，返回该距离。没有陆地或者水存在，返回-1。距离是曼哈顿距离，即 `(x0, y0)` 与 `(x1, y1)`的距离是|x0 - x1| + |y0 - y1|

### 方法

- 暴力：对每个0，找到最近的1，记录所有该距离的最大值。最坏时，$O(N^2/2)$个0和1，复杂度为$O(N^4)$
- BFS，同时从所有陆地出发，向四个方向遍历，最后到达的水单元即为最远距离的水单元。$T: O(N^2), S: O(N^2)$

```cpp
class Solution {
public:
    int maxDistance(vector<vector<int>>& grid) {
        int n = grid.size();
        queue<pair<int, int>> q;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    q.push({i, j});
                }
            }
        }
        if (q.size() == 0 || q.size() == n * n) return -1;
        int step = -1;
        int dir[5] = {1, 0, -1, 0, 1};
        while (!q.empty()) {
            int size = q.size();
            while (size--) {
                auto [row, col] = q.front();
                q.pop();
                for (int i = 0; i < 4; i++) {
                    int r = row + dir[i], c = col + dir[i + 1];
                    if (r < 0 || r >= n || c < 0 || c >= n || grid[r][c]) continue;
                    grid[r][c] = 1;
                    q.push({r, c});
                }
            }
            step++;
        }
        return step;
    }
};
```

## 1207. Unique Number of Occurrences

> :green_circle:

给一个整数数组，如果数组中每个元素的出现次数是唯一的，返回true，否则false。`1 <= arr.length <= 1000,-1000 <= arr[i] <= 1000 `

### 方法

- 数组哈希，统计每个元素的出现次数，然后判断是否已经出现过。T: O(n+K), S: O(K)

```cpp
class Solution {
public:
    bool uniqueOccurrences(vector<int>& arr) {
        int hash[2001] = {0};
        for (int i : arr) {
            hash[i + 1000] += 1;
        }
        bool occur[1001] = {false};
        for (int i : hash) {
            if (i != 0) {
                if (occur[i]) return false;
                else occur[i] = true;
            } 
        }
        return true;
    }
};
```

## 1235. Maximum Profit in Job Scheduling

> :red_circle:

### 方法

- 动态规划，dp[i]代表结束时间为i时所获得的最大利润，则做完工作j时，`dp[i] = max(dp[i], dp[startTime[j]] + profit[j])`
- 将工作按照结束时间排序，依次遍历每个工作，得到每个时间的最大利润，注意初始化`dp[i] = dp[i - 1]`
- 采用数组存储每个时间的最大利润时，其大小为所有工作的结束时间，会MLE。
- 改用有序MAP存储<时间，最大利润>，用二分搜索查找工作开始时间的最大利润，从而决定做不做当前工作。T: O(nlogn), S: O(n)
  - upper_bound(val)：第一个大于val的元素，lower_bound(val)：第一个不小于val的元素
  - std::map::rbegin()：map的最后一个元素的反向迭代器

<!-- tabs:start -->

####**First**

```cpp
class Solution {
public:
    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {
        int n = profit.size();
        vector<vector<int>> jobs;
        for (int i = 0; i < n; i++) {
            jobs.push_back({endTime[i], startTime[i], profit[i]});
        }
        sort(jobs.begin(), jobs.end());
        map<int, int> dp = {{0, 0}};
        for (auto& job : jobs) {
            int curProfit = prev(dp.upper_bound(job[1]))->second + job[2];
            if (curProfit > dp.rbegin()->second) {
                dp[job[0]] = curProfit;
            }
        }
        return dp.rbegin()->second;
    }
};
```

####**Second**

```cpp
class Solution {
static bool cmp(vector<int>& a, vector<int>& b) {
    return a[1] < b[1];
}
public:
    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {
        int n = profit.size();
        vector<vector<int>> jobs;
        for (int i = 0; i < n; i++) {
            jobs.push_back({startTime[i], endTime[i], profit[i]});
        }
        sort(jobs.begin(), jobs.end(), cmp);
        int end = jobs[n - 1][1];
        vector<int> dayProfit(end + 1);
        int index = 0;
        for (int i = 1; i <= end; i++) {
            dayProfit[i] = dayProfit[i - 1];
            while (index < n && jobs[index][1] == i) {
                dayProfit[i] = max(dayProfit[i], dayProfit[jobs[index][0]] + jobs[index][2]);
                index++;
            }
        }
        return dayProfit[end];
    }
};
/* Memory Limit Exceeded
startTime = [1,2,3,3], endTime = [3,4,5,1000000000], profit = [50,10,40,70]
*/
```

<!-- tabs:end -->

## 1275. Find Winner on a Tic Tac Toe Game

> :green_circle:

找出`3x3`井字棋的获胜者。A先B后，有三个相同的棋子排成一条线（行，列，对角线），或者无格可下时，游戏结束。返回获胜者“A”或"B"，平局返回"Draw"，未下完返回"Pending"

### 方法

- 共有8种获胜方式：3行3列，2个对角线。记录两个玩家这8种方式的棋子数，等于3则获胜

```cpp
class Solution {
public:
    string tictactoe(vector<vector<int>>& moves) {
        vector<vector<int>> num(2, vector<int>(8));
        int i = 0;
        for (auto& m : moves) {
            int r = m[0], c = m[1];
            num[i][r]++;
            num[i][c + 3]++;
            if (r == c) num[i][6]++;
            if (r == 2 - c) num[i][7]++;
            i = 1 - i;
        }
        for (int i = 0; i < 2; i++) {
            for (int j = 0; j < 8; j++) {
                if (num[i][j] == 3) return i == 0 ? "A" : "B";
            }
        }
        return moves.size() == 9 ? "Draw" : "Pending";
    }
};
```

## 1304. Find N Unique Integers Sum up to Zero

> :green_circle:

给一个正整数n，返回有n个独特整数的数组，其和为0

### 方法

- n为奇数时，以0为中心两侧各有n/2个数；n为偶数时，两侧各有n/2个数

<!-- tabs:start -->

####**First**

```cpp
class Solution {
public:
    vector<int> sumZero(int n) {
        vector<int> res;
        for (int i = 1; i <= n / 2; i++) {
            res.push_back(i);
            res.push_back(-i);
        }
        if (n % 2 != 0) res.push_back(0);
        return res;
    }
};
```

####**Second**

```cpp
class Solution {
public:
    vector<int> sumZero(int n) {
        vector<int> res(n);
        int left = 0, right = n - 1;
        int num = n / 2;
        while (left <= right) {
            res[left++] = -num;
            res[right--] = num;
            num--;
        }
        return res;
    }
};
```

<!-- tabs:end -->

## 1312. Minimum Insertion Steps to Make a String Palindrome

> :red_circle:

给一个字符串，每一步可以任意位置插入任意字符。返回最小的步数使得字符串称为回文字符串。

### 方法

- 

```cpp

```



## 1319. Number of Operations to Make Network Connected

> :orange_circle:

n台电脑，由光纤两两相连。移动一些边使得所有电脑相通，返回最小的移动数目，不能则返回-1

### 方法

- n个节点相连至少需要n-1条边。查找出连通分量的个数，其减1即为需要移动的边数。
- 可以通过DFS，BFS，并查集找出连通分量的个数

```cpp
class Solution {
public:
    int makeConnected(int n, vector<vector<int>>& connections) {
        if (connections.size() < n - 1) return -1;
        init(n);
        for (auto& c : connections) {
            join(c[0], c[1]);
        }
        int ans = 0;
        for (int i = 0; i < n; i++) {
            if (parent[i] == i) {
                ans++;
            }
        }
        return ans - 1;
    }
private:
    vector<int> parent;
    void init(int n) {
        for (int i  = 0; i < n; i++) {
            parent.push_back(i);
        }
    }

    int find(int u) {
        if (parent[u] != u) parent[u] = find(parent[u]);
        return parent[u];
    }

    void join(int u, int v) {
        u = find(u);
        v = find(v);
        if (u != v) parent[u] = v;
    }
};
```

## 1323. Maximum 69 Number

> :green_circle:

一个数，只包含6和9，6和9可替换，替换一个位置使其值最大

### 方法一

- 从左到右遍历，第一个6变为9，没有6则不变
- 直接将数字转为可迭代的字符串。T: O(L), S: O(L)

```cpp
class Solution {
public:
    int maximum69Number (int num) {
        string s = to_string(num);
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == '6') {
                s[i] = '9';
                break;
            }
        }
        return stoi(s);
    }
};
```

### 方法二

- 利用数学取余和除10，找到需要更改的位数。T: O(L), S: O(1)

```cpp
class Solution {
public:
    int maximum69Number (int num) {
        int numCopy = num;
        int index = -1;
        int pos = 0;
        while (num) {
            if (num % 10 == 6) index = pos;
            num /= 10;
            pos++;
        }
        return index == -1 ? numCopy : numCopy + 3 * pow(10, index);
    }
};
```

### 方法三

- 提取每个位置的数字，存进数组，更改遇到的第一个6。T: O(L), S: O(L)

```cpp
class Solution {
public:
    int maximum69Number (int num) {
        vector<int> number;
        while (num) {
            int a = num % 10;
            number.push_back(a);
            num = num / 10;
        }
        int res = 0;
        bool change = false;
        for (int i = number.size() - 1; i >= 0; i--) {
            if (number[i] == 6 && !change) {
                number[i] = 9;
                change = true;
            }
            res += number[i] * pow(10, i);
        }
        return res;
    }
};
```

## 1339. Maximum Product of Splitted Binary Tree

> :orange_circle:

给一个二叉树，移除一条边将其分为两个子树，返回两个子树的和的积的最大值。答案对`10^9 + 7`取余，要取余前找到最大答案。节点数 `[2, 5 * 10^4]`，节点值`1 <= Node.val <= 10^4`

### 方法

- 移除一条边，可得到边上子节点作为根节点的子树以及其余部分形成的子树。前者的子树和可通过遍历实时得到，后者的子树和可通过计算总和减去前者得到
- DFS后序遍历得到总和，再次遍历得到每个节点对应的前者子树和，然后更新积的最大值。T: O(N), S: O(H)
- 总和最大值为`5*10^8`，在int范围内。乘积最大值`25*10^16`，在long范围内。注意必须先找最大答案，最后再取余，否则结果不对

```cpp
class Solution {
public:
    int maxProduct(TreeNode* root) {
        sum = dfs(root);
        dfs(root);
        return res % (int)(1e9 + 7);
    }
private:
    long res = 0;
    long sum = 0;
    int dfs(TreeNode* node) {
        if (node == NULL) return 0;
        int curSum = dfs(node->left) + dfs(node->right) + node->val;
        if (sum != 0) {
            res = max(res, (sum - curSum) * curSum);
        }
        return curSum;
    }
};
```

## 1345. Jump Game IV

> :red_circle:

给一个整数数组`arr`，初始位于数组第一个位置，在位置i时可以跳跃到的三类位置是：`i+1; i-1; j, arr[j] = arr[i] & i != j`。返回达到数组最后一个位置的最少步数

### 方法

- BFS，先用map统计出每种数的位置，然后使用队列进行BFS，第一次到达目标的步数即为最少步数。T: O(n), S: O(n)
- 对于一种数，搜索过一次后，该数的所有位置均访问过，可以删掉map中的key，防止重复遍历

```cpp
class Solution {
public:
    int minJumps(vector<int>& arr) {
        int n = arr.size();
        if (n == 1) return 0;
        unordered_map<int, vector<int>> map;
        for (int i = 0; i < n; i++) map[arr[i]].push_back(i);
        queue<int> q;
        q.push(0);
        int step = 1;
        while (!q.empty()) {
            int size = q.size();
            while (size--) {
                int cur = q.front();
                q.pop();
                if (cur + 1 == n - 1) return step;
                if (map.count(arr[cur + 1])) {
                    q.push(cur + 1);
                }
                if (cur - 1 >= 0 && map.count(arr[cur - 1])) {
                    q.push(cur - 1);
                } 
                if (map.count(arr[cur])) {
                    for (int i : map[arr[cur]]) {
                        if (i == n - 1) return step;
                        if (i != cur) q.push(i);
                    }
                    map.erase(arr[cur]);
                }
            }
            step++;
        }
        return -1;
    }
};
```

## 1372. Longest ZigZag Path in a Binary Tree

> :orange_circle:

给一个二叉树的根节点，找到其中之字形路径（左右方向交替）的最大长度

### 方法

- DFS遍历整个二叉树，对于每个节点，根据之前方向选择继续遍历与重新遍历。T: O(n), S: O(n)

```cpp
class Solution {
public:
    int longestZigZag(TreeNode* root) {
        dfs(root, 0, 0);
        dfs(root, 1, 0);
        return ans;
    }
private:
    int ans = 0;
    void dfs(TreeNode* node, bool right, int step) {
        if (!node) return;
        ans = max(ans, step);
        if (right) {
            dfs(node->left, 0, step + 1);
            dfs(node->right, 1, 1);
        } else {
            dfs(node->right, 1, step + 1);
            dfs(node->left, 0, 1);
        }
    }
};
```

## 1386. Cinema Seat Allocation

> :orange_circle:

电影院有n行座位（标号1到n），每行10个（标号1到10），呈3-4-3分布。一些座位被预定，求出剩余的4连座的数量（标号为2345或4567或6789）

### 方法

- 每行最多2个4连座，1与10号座位可忽略。分块记录23, 45, 67, 89的座位是否被预定，采用map记录被预定座位的行的情况

```cpp
class Solution {
public:
    int maxNumberOfFamilies(int n, vector<vector<int>>& reservedSeats) {
        unordered_map<int, vector<int>> map;
        for (auto& r : reservedSeats) {
            if (r[1] > 1 && r[1] < 10) {
                if (map.find(r[0]) == map.end()) map[r[0]] = vector<int>(4, 1);
                map[r[0]][(r[1] - 2) / 2] = 0;
            }
        }
        int ans = 2 * (n - map.size());
        for (auto& [k, s] :  map) {
            int num = 0;
            if (s[1] && s[2] || s[0] && s[1] || s[2] && s[3])  num = 1;
            ans += num;
        }
        return ans;
    }
};
```

## 1402. Reducing Dishes

> :red_circle:

厨师有n道菜的满意度，并且一个时间单位做一道菜。一道菜的**Like-time coefficient**定义为完成时间及满意度乘积`time[i] * satisfaction[i]`，厨师可以删去一些菜并重新安排制作顺序，使得所有菜的**Like-time coefficient**总和最大

### 方法一

- 满意度有正有负，正满意度的菜一定保留，且满意度大的靠后完成。负满意度的菜逐步加入，以使得总和最大
- 将满意度升序排序，二分查找到第一个0满意度的菜，其后的菜全保留，其前的菜逐步判断是否加入

```cpp
class Solution {
public:
    int maxSatisfaction(vector<int>& satisfaction) {
        sort(satisfaction.begin(), satisfaction.end());
        int index = upper_bound(satisfaction.begin(), satisfaction.end(), -1) - satisfaction.begin();
        int n = satisfaction.size();
        int ans = 0, cnt = 0;
        for (int i = index; i < n; i++) {
            ans += (i - index + 1) * satisfaction[i];
            cnt += satisfaction[i];
        }
        while (index--) {
            cnt += satisfaction[index];
            if (cnt > 0) {
                ans += cnt;
            } else break;
        }
        return ans;
    }
};
```

### 方法二

- 满意度升序排序，直接从后往前遍历判断即可

```cpp
class Solution {
public:
    int maxSatisfaction(vector<int>& satisfaction) {
        sort(satisfaction.begin(), satisfaction.end());
        int n = satisfaction.size();
        int ans = 0, total = 0;
        for (int i = n - 1; i >= 0 && satisfaction[i] + total > 0 ; i--) {
            total += satisfaction[i];
            ans += total;
        }
        return ans;
    }
};
```

## 1408. String Matching in an Array

> :green_circle:

给一个字符串数组，返回所有是其它字符串子串的字符串。`1 <= words.length <= 100; 1 <= words[i].length <= 30`

### 方法

- 暴力遍历，判断一个字符串是否是其它字符串的子串。`s1.find(s2) != -1 || string::nops `代表找到

```cpp
class Solution {
public:
    vector<string> stringMatching(vector<string>& words) {
        vector<string> ans;
        for (int i = 0; i < words.size(); i++) {
            for (int j = 0; j < words.size(); j++) {
                if (i != j && words[j].find(words[i]) != words[j].npos) {
                    ans.push_back(words[i]);
                    break;
                }
            }
        }
        return ans;
    }
};
```

## 1416. Restore The Array

> :red_circle:

程序打印整数数组却忘记打印空格，得到了位数为s的字符串。已知数组中所有的数取值为[1, k]，没有0开始的数，返回可能的数组数量（对10^9 + 7取余）。

### 方法

- 

```cpp

```



## 1431. Kids With the Greatest Number of Candies

> :green_circle:

n个孩子各有糖果，给一些额外糖果，判断每个孩子加上这些额外糖果，是否糖果数量最多

### 方法

- 找到糖果的最大值，逐个判断每个孩子是否满足条件即可。T: O(n), S: O(n)

```cpp
class Solution {
public。
    vector<bool> kidsWithCandies(vector<int>& candies, int extraCandies) {
        int n = candies.size();
        vector<bool> ans(n);
        int maxVal = *max_element(candies.begin(), candies.end());
        for (int i = 0; i < n; i++) {
            ans[i] = candies[i] + extraCandies >= maxVal;
        }
        return ans;
    }
};
```

## 1443. Minimum Time to Collect All Apples in a Tree

> :orange_circle:

n个节点的无向树，下标从0到n-1，有些节点有苹果。沿一条边前进需要一秒，从下标0开始再回到下标0，返回收集所有苹果需要的最少时间

### 方法

- DFS后序遍历，统计子节点的情况，若子节点的子树有苹果或者子节点有苹果，则累加子节点时间并加2。T: O(n), S: O(n)
- 通过访问数组防止回头，也可以只记录父节点防止回头（节省空间）

```cpp
class Solution {
public:
    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {
        vector<vector<int>> graph(n);
        for (auto& e : edges) {
            graph[e[0]].push_back(e[1]);
            graph[e[1]].push_back(e[0]);
        }
        return dfs(graph, hasApple, 0, -1);
    }
private:
    int dfs(vector<vector<int>>& graph, vector<bool>& hasApple, int v, int parent) {
        int ans = 0;
        for (int u : graph[v]) {
            if (u == parent) continue;
            int time = dfs(graph, hasApple, u, v);
            if (time > 0 || hasApple[u]) ans += time + 2;
        }
        return ans;
    }
};
```

## 1444. Number of Ways of Cutting a Pizza

> :red_circle:

给一个矩形披萨，有些单元格有苹果。切k-1次，将披萨切为k块。每次可以竖着切并将左侧给人，或者横着切将上侧给人。返回切披萨的方式，使得每块披萨都至少含有一个苹果。结果对$$10^9 + 7$$取余

### 方法

- 

```cpp

```



## 1448. Count Good Nodes in Binary Tree

> :orange_circle:

统计二叉树中的好节点个数，好节点：从根节点到当前节点的路径中，没有大于当前节点值的节点

### 方法

- DFS遍历时记录路径中的最大值，后序遍历得到好节点的数量和

```cpp
class Solution {
public:
    int goodNodes(TreeNode* root) {
        return dfs(root, root->val);
    }
private:
    int dfs(TreeNode* node, int maxVal) {
        if (node == NULL) return 0;
        int ans = node->val < maxVal ? 0 : 1;
        maxVal = max(node->val, maxVal);
        ans += dfs(node->left, maxVal);
        ans += dfs(node->right, maxVal); 
        return ans;
    }
};
```

## 1466. Reorder Routes to Make All Paths Lead to the City Zero

> :orange_circle:

有n个城市，n-1条有向边。改变一些边的方向使得每个城市都能到达城市0，返回更改的最小数量

### 方法

- 将边视为双向边，记录边的顺序。DFS或BFS从0出发进行遍历，遇到的顺序的边都应该更改方向。

```cpp
class Solution {
public:
    int minReorder(int n, vector<vector<int>>& connections) {
        vector<vector<pair<int, int>>> adj(n);
        for (auto& c : connections) {
            adj[c[0]].push_back({c[1], 1});
            adj[c[1]].push_back({c[0], 0});
        }
        vis = vector<bool>(n);
        dfs(adj, 0);
        return ans;
    }
private:
    vector<bool> vis;
    int ans = 0;
    void dfs(vector<vector<pair<int, int>>>& adj, int node) {
        vis[node] = true;
        for (auto& [c, e] : adj[node]) {
            if (!vis[c]) {
                if (e == 1) ans++;
                dfs(adj, c);
            }
        }
    }
};
```

## 1470. Shuffle the Array

> :green_circle:

有2n个元素的数组 `[x1,x2,...,xn,y1,y2,...,yn]`，返回 `[x1,y1,x2,y2,...,xn,yn]`

### 方法

- 新建空数组，奇数位置选前，偶数位置选后，依次填充。T: O(n), S: O(1)

```cpp
class Solution {
public:
    vector<int> shuffle(vector<int>& nums, int n) {
        vector<int> ans(2 * n);
        for (int i = 0; i < n; i++) {
            ans[2 * i] = nums[i];
            ans[2 * i + 1] = nums[n + i];
        }
        return ans;
    }
};
```

## 1472. Design Browser History

> :orange_circle:

实现浏览器的浏览历史功能，从homepage开始，可以`visit`新的`url`，回退`steps`，前进`steps`

### 方法

- 用数组存储浏览的`url`，指针记录当前的位置，回退与前进不能超过数组范围。访问时`url`记在下个位置，并清空之后的记录
- 方法二：使用两个栈，一个保存历史记录，栈顶是当前位置；一个保存已有的未来记录，用于前进

```cpp
class BrowserHistory {
public:
    BrowserHistory(string homepage) {
        his.push_back(homepage);
        cur = 0;
    }
    
    void visit(string url) {
        cur += 1;
        his.resize(cur);
        his.push_back(url);
    }
    
    string back(int steps) {
        cur = max(0, cur - steps);
        return his[cur];
    }
    
    string forward(int steps) {
        cur = min((int)his.size() - 1, cur + steps);
        return his[cur];
    }

private:
    int cur;
    vector<string> his;
};
```

## 1519. Number of Nodes in the Sub-Tree With the Same Label

> :orange_circle:

n个节点的树，下标为0到n-1。根节点为0，每个节点有一个小写字母的标签。返回长度为n的答案数组，`ans[i]`代表节点i的子树上标签与节点i相同的节点数目。子树是该节点自身及其子孙

### 方法

- DFS，后序遍历，每个节点返回该节点子树包含的各个字母数量，不断累加直至根节点。T: O(26 * n), S: O(26 * n)
- 注意DFS函数的参数要使用引用，如`string& labels`，否则大量复制导致TLE

```cpp
class Solution {
public:
    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {
        vector<vector<int>> adj(n);
        for (auto& e : edges) {
            adj[e[0]].push_back(e[1]);
            adj[e[1]].push_back(e[0]);
        }
        vector<int> ans(n);
        dfs(adj, labels, 0, -1, ans);
        return ans;
    }
private:
    vector<int> dfs(vector<vector<int>>& adj, string& labels, int node, int parent, vector<int>& ans) {
        vector<int> hash(26, 0);
        for (int v : adj[node]) {
            if (v == parent) continue;
            vector<int> childHash = dfs(adj, labels, v, node, ans);
            for (int i = 0; i < 26; i++) {
                hash[i] += childHash[i];
            }
        }
        hash[labels[node] - 'a'] += 1;
        ans[node] = hash[labels[node] - 'a'];
        return hash;
    }
};
```

## 1523. Count Odd Numbers in an Interval Range

> :green_circle:

给两个非负整数low和high，返回`[low, high]`间（包括两端）的奇数的数量。`0 <= low <= high <= 10^9`

### 方法一

- `high-low+1`代表一共有多少个数。当low为奇数且总数量为奇数时，奇数数量为`n/2+1`，其余均为`n/2`。T: O(1), S: O(1)

```cpp
class Solution {
public:
    int countOdds(int low, int high) {
        int num = high - low + 1;
        if (low % 2 && num % 2) return num / 2 + 1;
        else return num / 2;
    }
};
```

### 方法二

- 1到low-1之间的奇数个数为`low / 2 `，1到high之间的奇数个数为`high + 1 / 2`

```cpp
class Solution {
public:
    int countOdds(int low, int high) {
        return (high + 1) / 2 - low / 2;
    }
};
```

### 方法三

- 设low为奇数，则之间的奇数数量为`(high - low) / 2 + 1`。若low为偶数，则加1变奇数，注意大于high的情况

```cpp
class Solution {
public:
    int countOdds(int low, int high) {
        if (low % 2 == 0) low++;
        return low > high ? 0 : (high - low) / 2 + 1;
    }
};
```

## 1539. Kth Missing Positive Number

> :green_circle:

严格递增顺序的正整数数组，返回第k个数组中缺失的正整数

### 方法一

- 数组严格递增且没有重复元素，从前向后遍历，寻找缺失的数。T: O(n), S: O(1)

```cpp
class Solution {
public:
    int findKthPositive(vector<int>& arr, int k) {
        for (int& a : arr) {
            if (a <= k) k++;
            else break;
        }
        return k;
    }
};
```

### 方法二

- 二分搜索，计算当前位置的数与当前位置应该的正整数的差值，与K进行比较。T: O(logn), S: O(1)

```cpp
class Solution {
public:
    int findKthPositive(vector<int>& arr, int k) {
        int l = 0, r = arr.size() - 1;
        while (l <= r) {
            int m = l + (r - l) / 2;
            if (arr[m] - m - 1 < k) {
                l = m + 1;
            } else {
                r = m - 1;
            }
        }
        return l + k;
    }
};
```

## 1544. Make The String Great

> :green_circle:

字符串，只包含大小写字母，删除相邻的大小写字母对

### 方法一

- 采用栈的思想，每次进栈时进行比较，字符串模拟栈。T: O(n), S: O(n)
- ASCII值：a=97, A=65; z=122, Z=90 大小写字母差为32
- 栈中字符可以直接转换为字符串: `string res(stack.begin(), stack.end());`

```cpp
class Solution {
public:
    string makeGood(string s) {
        string res = "";
        for (char c : s) {
            if (res.size() && abs(res.back() - c) == 32) {
                res.pop_back();
            } else res.push_back(c);
        }
        return res;
    }
};
```

### 方法二

- 双指针，in-place。T: O(n), S: O(1)

```cpp
class Solution {
public:
    string makeGood(string s) {
        int left = -1;
        for (int right = 0; right < s.size(); right++) {
            if (left != -1 && abs(s[left] - s[right]) == 32) {
                left--;
            } else s[++left] = s[right];
        }
        return left == -1 ? "" : s.substr(0, left + 1);
    }
};
```

## 1579. Remove Max Number of Edges to Keep Graph Fully Traversable

> :red_circle:

### 方法

- 

```cpp

```



## 1626. Best Team With No Conflicts

> :orange_circle:

建立一个整体得分最高的篮球队，每个队员有年龄以及得分。一个队中，年龄小的球员得分不能高于年龄大的。返回可能建立的篮球队的最高得分

### 方法

- 

```cpp

```

## 1639. Number of Ways to Form a Target String Given a Dictionary

> :red_circle:

给相同长度的单词，字符串

### 方法

- 

```cpp

```



## 1657. Determine if Two Strings Are Close

> :orange_circle:

判断两个字符串是否`close`，如果可以通过如下操作将一个字符串变为另一个：交换任两个位置的字符，相互转换任意两种字符

### 方法

- 统计两个字符串中出现的字符种类以及各字符个数，如果种类相同且字符个数相同，则满足要求
- 数组哈希，size为26，对其排序为常量，不考虑。T: O(n), S: O(1)

```cpp
class Solution {
public:
    bool closeStrings(string word1, string word2) {
        vector<int> hash1(26), hash2(26), hash3(26), hash4(26);
        for (char c : word1) {
            hash1[c - 'a']++;
            hash3[c - 'a'] = 1;
        }
        for (char c : word2) {
            hash2[c - 'a']++;
            hash4[c - 'a'] = 1;
        }
        sort(hash1.begin(), hash1.end());
        sort(hash2.begin(), hash2.end());
        return hash1 == hash2 && hash3 == hash4;
    }
};
```

## 1675. Minimize Deviation in Array

> :red_circle:

有n个正整数的数组，对数组的任意元素可以进行任意次两种类型的操作：元素是偶数则除以2，是奇数则乘以2。返回可以得到的数组最小差值

### 方法

- 所求数组最大值与最小值的差最小，即最大值尽可能小，最小值尽可能大。T: O(nlogn), S: O(n)
- 奇数只能变大，且乘以2就变成偶数。偶数只能变小，一直到变成奇数为止。
- 先将所有数最大化（奇数变为偶数），则只需减小操作即可。使用有序set，遍历寻找最大最小值，记录过程中的最小差值。

```cpp
class Solution {
public:
    int minimumDeviation(vector<int>& nums) {
        set<int> set;
        for (int n : nums) {
            if (n % 2 == 0) set.insert(n);
            else set.insert(n * 2);
        }
        int ans = *set.rbegin() - *set.begin();
        while (*set.rbegin() % 2 == 0) {
            int x = *set.rbegin();
            set.erase(x);
            set.insert(x / 2);
            ans = min(ans, *set.rbegin() - *set.begin());
        }
        return ans;
    }
};
```

## 1697. Checking Existence of Edge Length Limited Paths

> :red_circle:

### 方法

- 

```cpp

```



## 1704. Determine if String Halves Are Alike

> :green_circle:

给一个长度是偶数的字符串，判断前半部分与后半部分包含的元音字母数量是否相同，字符串包含大小写

### 方法

- 统计出前半部分与后半部分元音字母数量，进行比较即可。可用单变量的加减实现。T: O(n), S: O(1)

```cpp
class Solution {
public:
    bool halvesAreAlike(string s) {
        unordered_set<char> vowel = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};
        int cnt = 0;
        for (int i = 0; i < s.size(); i++) {
            if (vowel.find(s[i]) != vowel.end()) {
                if (i < s.size() / 2) cnt++;
                else cnt--;
            }
        }
        return cnt == 0;
    }
};
```

## 1706. Where Will the Ball Fall

> :orange_circle:

二维网格，上部和下部开放，左侧和右侧封闭。每个网格有一块对角线挡板，1代表左上到右下，-1代表右上到左下。从上部每一列放置一个小球，返回小球到达最下部时的列号。如果小球被“V”卡住，返回-1

### 方法

- DFS搜索每个小球的下落路径，依据当前位置的挡板方向，找到相邻位置的挡板方向，进而得到下落位置。T: O(M*N), S: O(M)
- 写法可以进行简化，将单独判断合并在一起：`newCol = col + grid[row][col]`

<!-- tabs:start -->

####**First**

```cpp
class Solution {
public:
    vector<int> findBall(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vector<int> res(n, -1);
        for (int i = 0; i < n; i++) {
            res[i] = dfs(grid, 0, i);
        }
        return res;
    }
private:
    int dfs(vector<vector<int>>& grid, int row, int col) {
        int m = grid.size(), n = grid[0].size();
        if (row == m) return col;
        if (grid[row][col] == 1) {
            if (col + 1 < n && grid[row][col + 1] == 1) {	
                return dfs(grid, row + 1, col + 1);
            } else return -1;
        } else {
            if (col - 1 >= 0 && grid[row][col - 1] == -1) {
                return dfs(grid, row + 1, col - 1);
            } else return -1;
        }
    }
};
```

####**Second**

```cpp
class Solution {
public:
    vector<int> findBall(vector<vector<int>>& grid) {
        vector<int> res(grid[0].size(), -1);
        for (int i = 0; i < grid[0].size(); i++) {
            res[i] = dfs(grid, 0, i);
        }
        return res;
    }
private:
    int dfs(vector<vector<int>>& grid, int row, int col) {
        int m = grid.size(), n = grid[0].size();
        if (row == m) return col;
        int newCol = col + grid[row][col];
        if (newCol >= 0 && newCol < n && grid[row][col] == grid[row][newCol]) {
            return dfs(grid, row + 1, newCol);
        } 
        return -1;
    }
};
```

<!-- tabs:end -->

## 1768. Merge Strings Alternately

> :green_circle:

交替合并两个字符串

### 方法

- 双指针，交替遍历两个字符串，添加到结果字符串即可。T: O(m+n), S: O(1)

```cpp
class Solution {
public:
    string mergeAlternately(string word1, string word2) {
        int m = word1.size();
        int n = word2.size();
        string result = "";
        int i = 0, j = 0;

        while (i < m || j < n) {
            if (i < m) {
                result.push_back(word1[i++]);
            }
            if (j < n) {
                result.push_back(word2[j++]);
            }
        }

        return result;
    }
};
```

## 1822. Sign of the Product of an Array

> :green_circle:

给定一维数组，返回所有元素乘积的正负号：1， -1，0

### 方法

- 无需计算最终乘积，只用统计正负号即可

```cpp
class Solution {
public:
    int arraySign(vector<int>& nums) {
        int sign = 1;
        for (int i : nums) {
            if (i < 0) sign = -sign;
            else if (i == 0) return 0;
        }
        return sign;
    }
};
```

## 1833. Maximum Ice Cream Bars

> :orange_circle:

整数数组代表冰激凌的价格，初始金钱为`coins`，返回能买到的最大数量的冰激凌

### 方法

- 贪心，按照价格排序，优先选择价格最小的，从而使数量尽可能多。T: O(nlogn), S: O(logn)

```cpp
class Solution {
public:
    int maxIceCream(vector<int>& costs, int coins) {
        sort(costs.begin(), costs.end());
        int ans = 0;
        for (int& c : costs) {
            if (c <= coins) {
                coins -= c;
                ans++;
            } else break;
        }
        return ans;
    }
};
```

## 1834. Single-Threaded CPU

> :orange_circle:

n个任务，id从`0`到`n-1`，`tasks[i] = [enqueueTimei, processingTimei]`代表任务的开始时间以及处理时间。单线程的CPU，每次处理一个任务，从当前可做的任务中挑选处理时间最短的，处理时间相同时挑选id最小的。返回CPU处理任务的id顺序

### 方法

- 将任务添加id，按照开始时间排序。记录当前时间，并将可做的任务加入小顶堆，完成堆顶的任务，更新当前时间及结果。T: O(NlogN), S: O(N)

```cpp
class Solution {
public:
    vector<int> getOrder(vector<vector<int>>& tasks) {
        vector<int> ans;
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> que;
        for (int i = 0; i < tasks.size(); i++) {
            tasks[i].push_back(i);
        }
        sort(begin(tasks), end(tasks));
        long time = tasks[0][0];
        int id = 0;
        while (ans.size() < tasks.size()) {
            while (id < tasks.size() && tasks[id][0] <= time) {
                que.push({tasks[id][1], tasks[id][2]});
                id++;
            }
            if (!que.empty()) {
                auto [t, tId] = que.top();
                que.pop();
                time += t;
                ans.push_back(tId);
            } else time = tasks[id][0];
        }
        return ans;
    }
};
```

## 1857. Largest Color Value in a Directed Graph

> :red_circle:

n个有色节点m条边的有向图，给字符串color代表每个节点的颜色。有效路径上的**颜色值**是最频繁出现的颜色的数量。找到图中任何有效路径的最大**颜色值**，若图有圈返回-1

### 方法

- 

```cpp

```

## 1926. Nearest Exit from Entrance in Maze

> :orange_circle:

二维地图上走迷宫，有墙和通道。给定起点，寻找到达出口的最小步数。出口在迷宫边界，起点不能作为出口

### 方法一

- DFS遍历所有出口，找到最短路径。DFS要遍历所有情况才能得到最小值，该方法TLE

```cpp
class Solution {
public:
    int nearestExit(vector<vector<char>>& maze, vector<int>& entrance) {
        dfs(maze, 0, entrance[0], entrance[1]);
        return minRes == INT_MAX ? -1 : minRes;
    }
private:
    int minRes = INT_MAX;
    void dfs(vector<vector<char>>& maze, int step, int row, int col) {
        int m = maze.size(), n = maze[0].size();
        if (row < 0 || col < 0 || row >= m || col >= n) return;
        if (maze[row][col] == '+') return;
        if (step > 0 && (row == 0 || col == 0 || row == m - 1 || col == n - 1)) {
            minRes = min(minRes, step);
            return;
        }
        maze[row][col] = '+';
        dfs(maze, step + 1, row + 1, col);
        dfs(maze, step + 1, row - 1, col);
        dfs(maze, step + 1, row, col + 1);
        dfs(maze, step + 1, row, col - 1);
        maze[row][col] = '-';
    }
};
```

### 方法二

- BFS相比DFS更适合寻找最短路径，只要遇到出口就是最近的出口，可以直接返回。T: O(mn), S: O(max(m,n))
- 尽可能早的判断是否到达出口，并设置已访问，可减少遍历时间。到达某个节点时再判断会TLE（代码中注释部分判断导致TLE）

```cpp
class Solution {
public:
    int nearestExit(vector<vector<char>>& maze, vector<int>& entrance) {
        int m = maze.size(), n = maze[0].size();
        queue<vector<int>> que;
        que.push(entrance);
        maze[entrance[0]][entrance[1]] = '+';
        int direc[5] = {0, 1, 0, -1, 0};
        int step = 0;
        while (!que.empty()) {
            int size = que.size();
            while (size--) {
                vector<int> loc = que.front();
                que.pop();
                // if (step > 0 && (loc[0] == 0 || loc[1] == 0 || loc[0] == m - 1 || loc[1] == n - 1)) return step;
                // maze[loc[0]][loc[1]] = '+';
                for (int i = 0; i < 4; i++) {
                    int row = loc[0] + direc[i];
                    int col = loc[1] + direc[i + 1];
                    if (row < 0 || col < 0 || row >= m || col >= n) continue;
                    if (maze[row][col] == '+') continue;
                    if (row == 0 || col == 0 || row == m - 1 || col == n - 1) return step + 1;
                    maze[row][col] = '+';
                    que.push({row, col});
                }
            }
            step++;
        }
        return -1;
    }
};
```

## 1962. Remove Stones to Minimize the Total

> :orange_circle:

整数数组`piles`代表每堆石头数量，做k次操作：任选一堆，移除`floor(piles[i] / 2)`块石头。返回最后可能剩下的最少的石头总量

### 方法

- 每次挑选石头最多的一堆，移除一半，采用优先队列维护数据。T: O(n + k logn), S: O(n)

```cpp
class Solution {
public:
    int minStoneSum(vector<int>& piles, int k) {
        int sum = accumulate(piles.begin(), piles.end(), 0);
        priority_queue<int> que(piles.begin(), piles.end());
        while (k--) {
            int x = que.top();
            que.pop();
            sum -= x / 2;
            que.push(x - x / 2);
        }
        return sum;
    }
};
```

## 1971. Find if Path Exists in Graph

> :green_circle:

n个顶点的双向图，判断从顶点 `source` 到 `destination`是否存在有效路径

### 方法一

- 递归式DFS，从出发点开始遍历，判断是否能到达目的节点。T : O(n + m), S: O(n)
- 注意，在dfs的参数列表中，graph不加引用&，会TLE

```cpp
class Solution {
public:
    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) {
        vector<vector<int>> graph(n);
        for (auto e : edges) {
            graph[e[0]].push_back(e[1]);
            graph[e[1]].push_back(e[0]);
        }
        vis = vector<bool>(n, false);
        return dfs(graph, source, destination);
    }
private:
    vector<bool> vis;
    bool dfs(vector<vector<int>>& graph, int source, int destination) {
        if (vis[source]) return false;
        vis[source] = true;
        if (source == destination) return true;
        for (int v : graph[source]) {
            if (dfs(graph, v, destination)) return true;
        }
        return false;
    }
};
```

### 方法二

- 并查集，出发节点与目的节点在一个连通分量，则一定存在一条有效路径。T: O(m*α(n)), S: O(n)

```cpp
class Solution {
public:
    vector<int> parent;     
    int findParent(int node) {
        return parent[node] == node ? node : (parent[node] = findParent(parent[node]));
    }    
    void makeSameGroup(int u , int v) {
        int pu = findParent(u) ; 
        int pv = findParent(v);
        parent[pu] = pv; 
    }
    
    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) {
        parent.resize(n);
        for(int i=0;i<n;i++)
            parent[i] = i; 
        
        for(auto e : edges) {
            makeSameGroup(e[0] , e[1]); 
        }                         
        return findParent(source) == findParent(destination); 
    }
};
```

