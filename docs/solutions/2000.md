# LeetCode 1000~2000

## 1047. Remove All Adjacent Duplicates In String

> :orange_circle:

反复移除字符串中相邻的两个相同字母，返回最终字符串

相似题目：1544. Make The String Great

### 方法

- 可以采用栈的思想进行移除，将字符串视为栈。T: O(n), S: O(n)
- 双指针法进行移除省空间。T: O(n), S: O(1)

```cpp
class Solution {
public:
    string removeDuplicates(string s) {
        int start = 0;
        for (int end = 0; end < s.size(); end++) {
            if (start > 0 && s[end] == s[start - 1]) {
                start--;
            } else s[start++] = s[end];
        }
        return s.substr(0, start);
    }
};
```

## 1304. Find N Unique Integers Sum up to Zero

> :green_circle:

给一个正整数n，返回有n个独特整数的数组，其和为0

### 方法

- n为奇数时，以0为中心两侧各有n/2个数；n为偶数时，两侧各有n/2个数

<!-- tabs:start -->

####**First**

```cpp
class Solution {
public:
    vector<int> sumZero(int n) {
        vector<int> res;
        for (int i = 1; i <= n / 2; i++) {
            res.push_back(i);
            res.push_back(-i);
        }
        if (n % 2 != 0) res.push_back(0);
        return res;
    }
};
```

####**Second**

```cpp
class Solution {
public:
    vector<int> sumZero(int n) {
        vector<int> res(n);
        int left = 0, right = n - 1;
        int num = n / 2;
        while (left <= right) {
            res[left++] = -num;
            res[right--] = num;
            num--;
        }
        return res;
    }
};
```

<!-- tabs:end -->

## 1323. Maximum 69 Number

> :green_circle:

一个数，只包含6和9，6和9可替换，替换一个位置使其值最大

### 方法一

- 从左到右遍历，第一个6变为9，没有6则不变
- 直接将数字转为可迭代的字符串。T: O(L), S: O(L)

```cpp
class Solution {
public:
    int maximum69Number (int num) {
        string s = to_string(num);
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == '6') {
                s[i] = '9';
                break;
            }
        }
        return stoi(s);
    }
};
```

### 方法二

- 利用数学取余和除10，找到需要更改的位数。T: O(L), S: O(1)

```cpp
class Solution {
public:
    int maximum69Number (int num) {
        int numCopy = num;
        int index = -1;
        int pos = 0;
        while (num) {
            if (num % 10 == 6) index = pos;
            num /= 10;
            pos++;
        }
        return index == -1 ? numCopy : numCopy + 3 * pow(10, index);
    }
};
```

### 方法三

- 提取每个位置的数字，存进数组，更改遇到的第一个6。T: O(L), S: O(L)

```cpp
class Solution {
public:
    int maximum69Number (int num) {
        vector<int> number;
        while (num) {
            int a = num % 10;
            number.push_back(a);
            num = num / 10;
        }
        int res = 0;
        bool change = false;
        for (int i = number.size() - 1; i >= 0; i--) {
            if (number[i] == 6 && !change) {
                number[i] = 9;
                change = true;
            }
            res += number[i] * pow(10, i);
        }
        return res;
    }
};
```

## 1544. Make The String Great
> :green_circle:

字符串，只包含大小写字母，删除相邻的大小写字母对

### 方法一

- 采用栈的思想，每次进栈时进行比较，字符串模拟栈。T: O(n), S: O(n)
- ASCII值：a=97, A=65; z=122, Z=90 大小写字母差为32
- 栈中字符可以直接转换为字符串: `string res(stack.begin(), stack.end());`

```cpp
class Solution {
public:
    string makeGood(string s) {
        string res = "";
        for (char c : s) {
            if (res.size() && abs(res.back() - c) == 32) {
                res.pop_back();
            } else res.push_back(c);
        }
        return res;
    }
};
```

### 方法二

- 双指针，in-place。T: O(n), S: O(1)

```cpp
class Solution {
public:
    string makeGood(string s) {
        int left = -1;
        for (int right = 0; right < s.size(); right++) {
            if (left != -1 && abs(s[left] - s[right]) == 32) {
                left--;
            } else s[++left] = s[right];
        }
        return left == -1 ? "" : s.substr(0, left + 1);
    }
};
```

## 1706. Where Will the Ball Fall

> :orange_circle:

二维网格，上部和下部开放，左侧和右侧封闭。每个网格有一块对角线挡板，1代表左上到右下，-1代表右上到左下。从上部每一列放置一个小球，返回小球到达最下部时的列号。如果小球被“V”卡住，返回-1

### 方法

- DFS搜索每个小球的下落路径，依据当前位置的挡板方向，找到相邻位置的挡板方向，进而得到下落位置。T: O(M*N), S: O(M)
- 写法可以进行简化，将单独判断合并在一起：`newCol = col + grid[row][col]`

<!-- tabs:start -->

####**First**

```cpp
class Solution {
public:
    vector<int> findBall(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vector<int> res(n, -1);
        for (int i = 0; i < n; i++) {
            res[i] = dfs(grid, 0, i);
        }
        return res;
    }
private:
    int dfs(vector<vector<int>>& grid, int row, int col) {
        int m = grid.size(), n = grid[0].size();
        if (row == m) return col;
        if (grid[row][col] == 1) {
            if (col + 1 < n && grid[row][col + 1] == 1) {	
                return dfs(grid, row + 1, col + 1);
            } else return -1;
        } else {
            if (col - 1 >= 0 && grid[row][col - 1] == -1) {
                return dfs(grid, row + 1, col - 1);
            } else return -1;
        }
    }
};
```

####**Second**

```cpp
class Solution {
public:
    vector<int> findBall(vector<vector<int>>& grid) {
        vector<int> res(grid[0].size(), -1);
        for (int i = 0; i < grid[0].size(); i++) {
            res[i] = dfs(grid, 0, i);
        }
        return res;
    }
private:
    int dfs(vector<vector<int>>& grid, int row, int col) {
        int m = grid.size(), n = grid[0].size();
        if (row == m) return col;
        int newCol = col + grid[row][col];
        if (newCol >= 0 && newCol < n && grid[row][col] == grid[row][newCol]) {
            return dfs(grid, row + 1, newCol);
        } 
        return -1;
    }
};
```

<!-- tabs:end -->

## 1822. Sign of the Product of an Array

> :green_circle:

给定一维数组，返回所有元素乘积的正负号：1， -1，0

### 方法

- 无需计算最终乘积，只用统计正负号即可

```cpp
class Solution {
public:
    int arraySign(vector<int>& nums) {
        int sign = 1;
        for (int i : nums) {
            if (i < 0) sign = -sign;
            else if (i == 0) return 0;
        }
        return sign;
    }
};
```

## 1926. Nearest Exit from Entrance in Maze

> :orange_circle:

二维地图上走迷宫，有墙和通道。给定起点，寻找到达出口的最小步数。出口在迷宫边界，起点不能作为出口

### 方法一

- DFS遍历所有出口，找到最短路径。DFS要遍历所有情况才能得到最小值，该方法TLE

```cpp
class Solution {
public:
    int nearestExit(vector<vector<char>>& maze, vector<int>& entrance) {
        dfs(maze, 0, entrance[0], entrance[1]);
        return minRes == INT_MAX ? -1 : minRes;
    }
private:
    int minRes = INT_MAX;
    void dfs(vector<vector<char>>& maze, int step, int row, int col) {
        int m = maze.size(), n = maze[0].size();
        if (row < 0 || col < 0 || row >= m || col >= n) return;
        if (maze[row][col] == '+') return;
        if (step > 0 && (row == 0 || col == 0 || row == m - 1 || col == n - 1)) {
            minRes = min(minRes, step);
            return;
        }
        maze[row][col] = '+';
        dfs(maze, step + 1, row + 1, col);
        dfs(maze, step + 1, row - 1, col);
        dfs(maze, step + 1, row, col + 1);
        dfs(maze, step + 1, row, col - 1);
        maze[row][col] = '-';
    }
};
```

### 方法二

- BFS相比DFS更适合寻找最短路径，只要遇到出口就是最近的出口，可以直接返回。T: O(mn), S: O(max(m,n))
- 尽可能早的判断是否到达出口，并设置已访问，可减少遍历时间。到达某个节点时再判断会TLE（代码中注释部分判断导致TLE）

```cpp
class Solution {
public:
    int nearestExit(vector<vector<char>>& maze, vector<int>& entrance) {
        int m = maze.size(), n = maze[0].size();
        queue<vector<int>> que;
        que.push(entrance);
        maze[entrance[0]][entrance[1]] = '+';
        int direc[5] = {0, 1, 0, -1, 0};
        int step = 0;
        while (!que.empty()) {
            int size = que.size();
            while (size--) {
                vector<int> loc = que.front();
                que.pop();
                // if (step > 0 && (loc[0] == 0 || loc[1] == 0 || loc[0] == m - 1 || loc[1] == n - 1)) return step;
                // maze[loc[0]][loc[1]] = '+';
                for (int i = 0; i < 4; i++) {
                    int row = loc[0] + direc[i];
                    int col = loc[1] + direc[i + 1];
                    if (row < 0 || col < 0 || row >= m || col >= n) continue;
                    if (maze[row][col] == '+') continue;
                    if (row == 0 || col == 0 || row == m - 1 || col == n - 1) return step + 1;
                    maze[row][col] = '+';
                    que.push({row, col});
                }
            }
            step++;
        }
        return -1;
    }
};
```

