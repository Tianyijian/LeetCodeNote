# LeetCode 1000~2000

## 1047. Remove All Adjacent Duplicates In String

> :orange_circle:

反复移除字符串中相邻的两个相同字母，返回最终字符串

相似题目：1544. Make The String Great

### 方法

- 可以采用栈的思想进行移除，将字符串视为栈。T: O(n), S: O(n)
- 双指针法进行移除省空间。T: O(n), S: O(1)

```cpp
class Solution {
public:
    string removeDuplicates(string s) {
        int start = 0;
        for (int end = 0; end < s.size(); end++) {
            if (start > 0 && s[end] == s[start - 1]) {
                start--;
            } else s[start++] = s[end];
        }
        return s.substr(0, start);
    }
};
```



## 1323. Maximum 69 Number

> :green_circle:

一个数，只包含6和9，6和9可替换，替换一个位置使其值最大

### 方法一

- 从左到右遍历，第一个6变为9，没有6则不变
- 直接将数字转为可迭代的字符串。T: O(L), S: O(L)

```cpp
class Solution {
public:
    int maximum69Number (int num) {
        string s = to_string(num);
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == '6') {
                s[i] = '9';
                break;
            }
        }
        return stoi(s);
    }
};
```

### 方法二

- 利用数学取余和除10，找到需要更改的位数。T: O(L), S: O(1)

```cpp
class Solution {
public:
    int maximum69Number (int num) {
        int numCopy = num;
        int index = -1;
        int pos = 0;
        while (num) {
            if (num % 10 == 6) index = pos;
            num /= 10;
            pos++;
        }
        return index == -1 ? numCopy : numCopy + 3 * pow(10, index);
    }
};
```

### 方法三

- 提取每个位置的数字，存进数组，更改遇到的第一个6。T: O(L), S: O(L)

```cpp
class Solution {
public:
    int maximum69Number (int num) {
        vector<int> number;
        while (num) {
            int a = num % 10;
            number.push_back(a);
            num = num / 10;
        }
        int res = 0;
        bool change = false;
        for (int i = number.size() - 1; i >= 0; i--) {
            if (number[i] == 6 && !change) {
                number[i] = 9;
                change = true;
            }
            res += number[i] * pow(10, i);
        }
        return res;
    }
};
```

## 1544. Make The String Great
> :green_circle:

字符串，只包含大小写字母，删除相邻的大小写字母对

### 方法一

- 采用栈的思想，每次进栈时进行比较，字符串模拟栈。T: O(n), S: O(n)
- ASCII值：a=97, A=65; z=122, Z=90 大小写字母差为32
- 栈中字符可以直接转换为字符串: `string res(stack.begin(), stack.end());`

```cpp
class Solution {
public:
    string makeGood(string s) {
        string res = "";
        for (char c : s) {
            if (res.size() && abs(res.back() - c) == 32) {
                res.pop_back();
            } else res.push_back(c);
        }
        return res;
    }
};
```

### 方法二

- 双指针，in-place。T: O(n), S: O(1)

```cpp
class Solution {
public:
    string makeGood(string s) {
        int left = -1;
        for (int right = 0; right < s.size(); right++) {
            if (left != -1 && abs(s[left] - s[right]) == 32) {
                left--;
            } else s[++left] = s[right];
        }
        return left == -1 ? "" : s.substr(0, left + 1);
    }
};
```

## 1706. Where Will the Ball Fall

> :orange_circle:

二维网格，上部和下部开放，左侧和右侧封闭。每个网格有一块对角线挡板，1代表左上到右下，-1代表右上到左下。从上部每一列放置一个小球，返回小球到达最下部时的列号。如果小球被“V”卡住，返回-1

### 方法

- DFS搜索每个小球的下落路径，依据当前位置的挡板方向，找到相邻位置的挡板方向，进而得到下落位置。T: O(M*N), S: O(M)
- 写法可以进行简化，将单独判断合并在一起：`newCol = col + grid[row][col]`

<!-- tabs:start -->

####**First**

```cpp
class Solution {
public:
    vector<int> findBall(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vector<int> res(n, -1);
        for (int i = 0; i < n; i++) {
            res[i] = dfs(grid, 0, i);
        }
        return res;
    }
private:
    int dfs(vector<vector<int>>& grid, int row, int col) {
        int m = grid.size(), n = grid[0].size();
        if (row == m) return col;
        if (grid[row][col] == 1) {
            if (col + 1 < n && grid[row][col + 1] == 1) {	
                return dfs(grid, row + 1, col + 1);
            } else return -1;
        } else {
            if (col - 1 >= 0 && grid[row][col - 1] == -1) {
                return dfs(grid, row + 1, col - 1);
            } else return -1;
        }
    }
};
```

####**Second**

```cpp
class Solution {
public:
    vector<int> findBall(vector<vector<int>>& grid) {
        vector<int> res(grid[0].size(), -1);
        for (int i = 0; i < grid[0].size(); i++) {
            res[i] = dfs(grid, 0, i);
        }
        return res;
    }
private:
    int dfs(vector<vector<int>>& grid, int row, int col) {
        int m = grid.size(), n = grid[0].size();
        if (row == m) return col;
        int newCol = col + grid[row][col];
        if (newCol >= 0 && newCol < n && grid[row][col] == grid[row][newCol]) {
            return dfs(grid, row + 1, newCol);
        } 
        return -1;
    }
};
```

<!-- tabs:end -->
