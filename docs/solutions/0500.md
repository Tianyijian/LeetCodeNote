# LeetCode 0000~0500

## 0002. Add Two Numbers

> :orange_circle:

给两个非空链表，代表两个非负整数。数字逆序存储在链表上，每个节点存储一位。将两个数字相加，并返回新的链表

### 方法

- 两个指针遍历两个链表，将每一位相加，注意有进位的情况。进位可以直接`addNext = sum / 10`得到
- 可以建立新链表存储值，也可以直接加在原有的链表上。可以先遍历得到两个链表的长度，也可以不提前遍历
- 不提前计算长度时，两个链表都需要更新数值，谁有加谁，最后返回剩余的即可。T: O(max(m, n)), S: O(1)
- 为了知道最后留下的链表，遍历时条件为`p && p->next`。长度相等，最后各剩一个；长度不同，剩下长的最后一个

```cpp
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode *p1 = l1, *p2 = l2;
        int sum = 0, addNext = 0;
        while ((p1 && p1->next) || (p2 && p2->next)) {
            sum = addNext;
            if (p1) sum += p1->val;
            if (p2) sum += p2->val;
            if (sum > 9) {
                sum = sum % 10;
                addNext = 1;
            } else addNext = 0;
            if (p1) {
                p1->val = sum;
                p1 = p1->next;
            }
            if (p2) {
                p2->val = sum;
                p2 = p2->next;
            }
        }
        if (p1) {
            p1->val += addNext;
            if (p2) p1->val += p2->val;
            if (p1->val > 9) {
                p1->val %= 10;
                p1->next = new ListNode(1);
            }
            return l1;
        } else {
            p2->val += addNext;
            if (p2->val > 9) {
                p2->val %= 10;
                p2->next = new ListNode(1);
            }
            return l2;
        }
    }
};
```

## 0004. Median of Two Sorted Arrays

> :red_circle:

给定两个有序数组，求中位数，要求O(log(m+n))

### 方法

- 二分查找有序数组为O(logn)，利用二分定位中位数的位置
- 利用二分分割较短的数组，根据总长度分割长数组，依据左侧与右侧的大小，移动分割位置。T: O(log(min(m, n))), S: O(1)
- 参考：https://www.youtube.com/watch?v=LPFhl65R7ww

```cpp
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int M = nums1.size(), N = nums2.size();
        if (M > N) return findMedianSortedArrays(nums2, nums1);

        int l = 0, r = M;
        while (l <= r) {
            int partition1 = ((size_t)l + r) / 2;
            int partition2 = (M + N + 1) / 2 - partition1;

            int max1_left = partition1 != 0 ? nums1[partition1 - 1] : INT_MIN;
            int max2_left = partition2 != 0 ? nums2[partition2 - 1] : INT_MIN;

            int min1_right = partition1 != M ? nums1[partition1] : INT_MAX;
            int min2_right = partition2 != N ? nums2[partition2] : INT_MAX;

            if (max1_left <= min2_right && max2_left <= min1_right) {
                int max_left = max(max1_left, max2_left);
                int min_right = min(min1_right, min2_right);
                return (M + N) % 2 ? max_left : (max_left + min_right) / 2.0;
            }

            if (max2_left > min1_right) {
                l = partition1 + 1;
            } else {
                r = partition1 - 1;
            }
        }
        return -1;
    }
};
```

## 0006. Zigzag Conversion

> :orange_circle:

将一个字符串在给定的行数上，从左至右竖着进行之字形排列。返回按行读取的排列结果

### 方法

- 字符串遍历。按照行进行遍历，找到循环节，确定需要添加的字符的位置，进行循环。T: O(n), S: O(1)

```cpp
class Solution {
public:
    string convert(string s, int numRows) {
        if (numRows == 1) return s;
        string ans;
        int n = s.size(), iter = 2 * numRows - 2;
        for (int i = 0; i < numRows; i++) {
            for (int j = 0; j < n; j += iter) {
                if (j + i < n) ans.push_back(s[j + i]);
                if (i == 0 || i == numRows - 1) continue;
                if (j + iter - i < n) ans.push_back(s[j + iter - i]);
            }
        }
        return ans;
    }
};
```

## 0008. String to Integer (atoi)

> :orange_circle:

将字符串转化为整数，读入顺序为空格，正负号，数字，数值溢出时保留在[-2^31, 2^31-1]

### 方法

- 要以正确的顺序读入，如一但开始读入数字，则空格，符号就停止读入，如`“  4+2”`
- 数值可能非常大，判断有溢出时可以立即停止读入，[-2147483648, 2147483647]，如示例`“2000000000000”`
- 写法一：利用for循环遍历数组，判断当前字符能否读入，并进行处理
- 写法二：记录读入的下标，while循环进行处理

<!-- tabs:start -->

####**First**

```cpp
class Solution {
public:
    int myAtoi(string s) {
        bool canReadSpace = true;
        bool canReadSign = true;
        bool neg = false;
        long num = 0;
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == ' '){
                if (!canReadSpace) break;
            } else if (s[i] == '-' || s[i] == '+') {
                if (!canReadSign) break;
                canReadSpace = false;
                canReadSign = false;
                if (s[i] == '-') neg = true;
            } else if (s[i] >= '0' && s[i] <= '9') {
                canReadSign = false;
                canReadSpace = false;
                num = num * 10 + (s[i] - '0');
                if (num - 1 > INT32_MAX) break;
            } else {
                break;
            }
        }
        if (neg) num = -num;
        if (num > INT32_MAX) num = INT32_MAX;
        if (num < INT32_MIN) num = INT32_MIN;
        return (int)num;
    }
};
```

####**Second**

```cpp
class Solution {
public:
    int myAtoi(string s) {
        int sign = 1, num = 0, i = 0;
        while (s[i] == ' ') i++;
        if (s[i] == '-' || s[i] == '+') {
            sign = (s[i] == '-') ? -1 : 1;
            i++;
        }
        while (s[i] >= '0' && s[i] <= '9') {
            if (num > INT_MAX / 10 || (num == INT_MAX / 10 && s[i] - '0' > 7)) {
                if (sign == 1) return INT_MAX;
                else return INT_MIN;
            }
            num = num * 10 + (s[i] - '0');
            i++;
        }
        return sign * num;
    }
};
```

<!-- tabs:end -->

## 0009. Palindrome Number

> :green_circle:

给一个整数x，判断是否回文。如`121`是，而`10, -121`不是。`-2^31 <= x <= 2^31 - 1`

### 方法一

- 将其转为字符串，双指针从两侧向中间扫描判断

```cpp
class Solution {
public:
    bool isPalindrome(int x) {
        string s = to_string(x);
        int left = 0, right = s.size() - 1;
        while (left < right) {
            if (s[left++] != s[right--]) return false;
        }
        return true;
    }
};
```

### 方法二

- Follow up：不转换为字符串。负数不是回文，将数字的每一位取出来，然后双指针判断

```cpp
class Solution {
public:
    bool isPalindrome(int x) {
        if (x < 0) return false;
        vector<int> nums;
        while (x) {
            nums.push_back(x % 10);
            x = x / 10;
        }
        int left = 0, right = nums.size() - 1;
        while (left < right) {
            if (nums[left++] != nums[right--]) return false;
        }
        return true;
    }
};
```

### 方法三

- 将整个数字反转，比较与其本身是否相等。但可能会有超过INT_MAX溢出的情况
- 考虑将数字的一半反转。T: O(log10(*n*)), S: O(1)

```cpp
class Solution {
public:
    bool isPalindrome(int x) {
        if (x < 0 || (x != 0 && x % 10 == 0)) return false;
        int reverseNum = 0;
        while (x > reverseNum) {
            reverseNum = reverseNum * 10 + x % 10;
            x = x / 10;
        }
        return x == reverseNum || x == reverseNum / 10;
    }
};
```

## 0013. Roman to Integer

> :green_circle:

将罗马数字转换为整数。罗马数字共有7个符号，从左到右值最大到最小。当左侧值小于右侧值时，左侧值是被减去的

### 方法

- 记录结果，从左至右扫描，遇到当前符号小于右侧符号的，结果减去当前数，否则加上当前数。T: O(n), S: O(1)

```cpp
class Solution {
public:
    int romanToInt(string s) {
        unordered_map<char, int> map = {{'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, {'C', 100}, {'D', 500}, {'M', 1000}};
        int res = 0;
        for (int i = 0; i < s.size() - 1; i++) {
            if (map[s[i]] < map[s[i + 1]]) {
                res -= map[s[i]];
            } else res += map[s[i]];
        }
        res += map[s.back()];
        return res;
    }
};
```

## 0020. Valid Parentheses

> :green_circle:

给定字符串包含`{, [, (, ), ], }`，判断是否有效。

### 方法

- 字符串模拟栈的操作，栈中添加左括号对应的右括号

```cpp
class Solution {
public:
    bool isValid(string s) {
        if (s.size() % 2 != 0) return false;
        string st;
        for (char c : s) {
            if (c == st.back()) st.pop_back();
            else if (c == '(') st.push_back(')');
            else if (c == '[') st.push_back(']');
            else if (c == '{') st.push_back('}');
            else return false;
        }
        return st.size() == 0;
    }
};
```

## 0022. Generate Parentheses

> :orange_circle:

给n对括号，生成所有的格式良好的括号组合

### 方法

- 回溯，递归记录遍历的路径，按照一定条件添加可以选择的括号
- 写法一：记录剩余的左括号与右括号的数量，相等时必选左括号，左括号数量少时两者都可选择
- 写法二：记录剩余的左括号与右括号的数量，有左括号即可选择，剩余右括号多于左括号时可以选择
- T: O(4^n/n), S: O(4^n/n)

<!-- tabs:start -->

####**First**

```cpp
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        res.clear();
        path = "";
        backtracking(n, n);
        return res;
    }
private:
    vector<string> res;
    string path;
    void backtracking(int left, int right) {
        if (left < 0 || right < 0) return;
        if (left == 0 && right == 0) {
            res.push_back(path);
            return;
        }
        if (left == right) {
            path += "(";
            backtracking(left - 1, right);
            path.pop_back();
        } else {
            for (int i = 0; i < 2; i++) {
                if (i == 0) path += "(";
                else path += ")";
                backtracking(left - 1 + i, right - i);
                path.pop_back();
            }
        }
    }
};
```

####**Second**

```cpp
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        res.clear();
        path = "";
        backtracking(n, n);
        return res;
    }
private:
    vector<string> res;
    string path;
    void backtracking(int left, int right) {
        if (left == 0 && right == 0) {
            res.push_back(path);
            return;
        }
        if (left > 0) {
            path += "(";
            backtracking(left - 1, right);
            path.pop_back();
        } 
        if (right > left)  {
            path += ")";
            backtracking(left, right - 1);
            path.pop_back();
        }
    }
};
```

<!-- tabs:end -->

## 0032. Longest Valid Parentheses

> :red_circle:

给定一个字符串，仅包含`(,)`，找到最长的括号有效的子串，返回其长度

### 方法

- 暴力搜索：两层循环找到每个子串，再判断子串有效性。T: O(n^3), S: O(n)
- 动态规划：`dp[i][j]`是否是括号有效的子串，记录最长的长度，T: O(n^2), S: O(n^2)
- 动态规划2：`dp[i]`是以i结尾的最长有效子串的长度。T: O(n), S: O(n)
- 采用栈，栈中记录下标，每次可以括号消除时，计算栈顶到当前的距离，更新最大长度。注意空栈。T: O(n), S: O(n)

```cpp
class Solution {
public:
    int longestValidParentheses(string s) {
        stack<int> st;
        int res = 0;
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == ')' && st.size()) {
                if (s[st.top()] == '(') {
                    st.pop();
                    int j = st.size() ? st.top() : -1;
                    res = max(res, i - j);
                    continue;
                }
            } 
            st.push(i);
        }
        return res;
    }
};
```

## 0033. Search in Rotated Sorted Array

> :orange_circle:

一维升序数组，可能进行部分旋转后，在其中搜索某个元素位置，O(logn)实现

### 方法

- 二分查找升序数组为O(logn)，旋转数组可以通过局部及整体reverse实现
- 选择一个点将数组分割，其中一部分一定有序，根据mid判断mid在有序部分还是无序部分：
  - mid<left，在右边有序部分，mid>=left，在左边有序部分（注意等号）

- 比较target与有序部分的边界关系，舍弃另一部分
  - 如mid在右侧有序部分[mid, right]，若target>=mid && target<=end，则target在右侧有序部分，舍弃左边部分（start=mid+1）


```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) return mid;
            if (nums[left] <= nums[mid]) {  //[left,mid]有序
                if (nums[left] <= target && nums[mid] >= target) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            } else {						//[mid,right]有序
                if (nums[mid] <= target && nums[right] >= target) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
        }
        return -1;
    }
};
```

## 0036. Valid Sudoku

> :orange_circle:

给定一个`9x9`的数独，判断数独是否有效。每行，每列，及每个`3x3`的格子内，不能有重复的1~9数字

### 方法

- 判断是否有数字重复，可以采用数组哈希。对行、列、格子都建立查重数组，可以一遍遍历。T: O(n^2), S: O(n^2)
- 对于格子，关键在于根据二维下标`i, j`转换为查重数组的一维下标`k = i / 3 * 3 + j / 3`

```cpp
class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        int rowUsed[9][9] = {0}, colUsed[9][9] = {0}, boxUsed[9][9] = {0}; 
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                if (board[i][j] != '.') {
                    int num = board[i][j] - '0' - 1;
                    int k = i / 3 * 3 + j / 3;
                    if (rowUsed[i][num] || colUsed[j][num] || boxUsed[k][num]) return false;
                    rowUsed[i][num] = colUsed[j][num] = boxUsed[k][num] = 1;
                }
            }
        }
        return true;
    }
};
```

## 0041. First Missing Positive

> :red_circle:

给定一个没有排序的整数数组，返回最小的缺失的正整数。O(n)并且常数空间

### 方法一

- 最终答案在[1, n + 1]，把所有的元素放置在相应的位置，忽略大于n或者小于等于0的
- 比如3放置在第三个位置，`[3,1,-4,7] -> [-4,1,3,7] -> [1,-4,3,7]  `，最终`nums[1] != 2`，返回2。T: O(n), S: O(1)

```cpp
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int n = nums.size(); 
        for (int i = 0; i < n; i++) {
            while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {
                swap(nums[i], nums[nums[i] - 1]);
            }       
        }
        for (int i = 0; i < n; i++) {
            if (nums[i] != i + 1) return i + 1;
        }
        return n + 1;
    }
};
```

### 方法二

- `1 <= nums.length <= 100000`，因此最多填满[1, n]。可以用数组哈希，设立数组长度为100005或者n + 1即可
- 该方法空间使用不符合要求。T: O(n), S: O(n)

```cpp
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int hash[100005] = {0};
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] > 0 && nums[i] < 100005) {
                hash[nums[i]] = 1;
            }
        }
        for (int i = 1; i < 100005; i++) {
            if (hash[i] == 0) return i;
        }
        return 0;
    }
};
```

## 0043. Multiply Strings

> :orange_circle:

给两个字符串形式的非负整数，计算两个数的乘积，返回字符串形式的结果。不能使用内置的大数库以及直接将输入转换为整数。`1 <= num1.length, num2.length <= 200`

### 方法

- 字符串最多有200位，不能直接转换为整数计算。模拟两个数的竖式乘法，考虑按位计算，m位数与n位数的乘积最多有`m+n`位
- 直接使用`m+n`位的字符串存储结果。按位计算时，确认结果的存储位置，处理进位的情况。T: O(m*n), S: O(m+n)

<!-- tabs:start -->

####**First**

```cpp
class Solution {
public:
    string multiply(string num1, string num2) {
        if (num1 == "0" || num2 == "0") return "0";
        int m = num1.size(), n = num2.size();
        string ans(m + n, '0');
        for (int i = m - 1; i >= 0; i--) {
            for (int j = n - 1; j >= 0; j--) {
                int k = (m - 1 - i) + (n - 1 - j);
                int val = (num1[i] - '0') * (num2[j] - '0');
                val += (ans[k] - '0');
                ans[k] = val % 10 + '0';
                ans[k + 1] += val / 10;
            }
        }
        while (ans.back() == '0') ans.pop_back();
        reverse(ans.begin(), ans.end());
        return ans;
    }
};
```

####**Second**

```cpp
class Solution {
public:
    string multiply(string num1, string num2) {
        if (num1 == "0" || num2 == "0") return "0";
        int m = num1.size(), n = num2.size();
        string ans(m + n, '0');
        for (int i = m - 1; i >= 0; i--) {
            for (int j = n - 1; j >= 0; j--) {
                int val = (num1[i] - '0') * (num2[j] - '0') + (ans[i + j + 1] - '0');
                ans[i + j + 1] = val % 10 + '0';
                ans[i + j] += val / 10;
            }
        }
        for (int i = 0; i < m + n; i++) {
            if (ans[i] != '0') return ans.substr(i);
        }
        return "0";
    }
};
```

<!-- tabs:end -->

## 0048. Rotate Image

> :orange_circle:

二维矩阵，顺时针旋转90度。要求in-place操作。

### 方法

- 写法一：可以直接元素交换，1与2交换，3与4交换，1与3交换，注意循环不变量
- 写法二：存一个临时元素，直接移动到位置即可

<!-- tabs:start -->

####**First**

```cpp
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        int cicle = (n + 1) / 2;
        for (int j = 0; j < cicle; j++) {
            int last = n - 1 - j;
            for (int i = j; i < last; i++) {
                swap(matrix[j][i], matrix[i][last]);
                swap(matrix[last][n - 1 - i], matrix[n - 1 - i][j]);
            }
            for (int i = j; i < last; i++) {
                swap(matrix[j][i], matrix[last][n - 1 - i]);
            }
        }
    }
};
```

####**Second**

```cpp
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        for (int i = 0; i < (n + 1) / 2; i ++) {
            for (int j = 0; j < n / 2; j++) {
                int temp = matrix[n - 1 - j][i];
                matrix[n - 1 - j][i] = matrix[n - 1 - i][n - j - 1];
                matrix[n - 1 - i][n - j - 1] = matrix[j][n - 1 -i];
                matrix[j][n - 1 - i] = matrix[i][j];
                matrix[i][j] = temp;
            }
        }
    }
};
```

<!-- tabs:end -->

## 0049. Group Anagrams

> :orange_circle:

字符串数组，将字母异位词分组。**字母异位词**是源单词的字母重新排列得到的新单词

### 方法

- 统计每个字符串各个字母的出现次数，将其拼接作为key（也可以直接排序作为key），用于区分每个字符串

```cpp
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        vector<vector<string>> ans;
        unordered_map<string, int> map;
        for (auto& s : strs) {
            int hash[26] = {0};
            for (char& c : s) hash[c - 'a']++;
            string str;
            for (int i = 0; i < 26; i++) {
                if (hash[i] > 0) str.append(hash[i], i + 'a');
            }
            if (map.find(str) != map.end()) {
                ans[map[str]].push_back(s);
            } else {
                map[str] = ans.size();
                ans.push_back(vector<string>{s});
            }
        }
        return ans;
    }
};
```

## 0054. Spiral Matrix

> :orange_circle:

`mxn`矩阵，以螺旋顺序返回所有元素

### 方法

- 按圈进行读取，依次读取四周，注意使用循环不变量，最中心剩一行或者一列时，直接读取。T: O(mn), S: O(1)

```cpp
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        int m = matrix.size(), n = matrix[0].size();
        vector<int> ans;
        int circle = (min(m, n) + 1) / 2;
        for (int c = 0; c < circle; c++) {
            if (c == m - 1 - c) {
                for (int j = c; j <= n - c - 1; j++) ans.push_back(matrix[c][j]);
                continue;
            } else if (c == n - 1 - c) {
                for (int i = c; i <= m - 1 - c; i++) ans.push_back(matrix[i][c]);
                continue;
            } 

            for (int j = c; j < n - c - 1; j++) {
                ans.push_back(matrix[c][j]);
            }
            for (int i = c; i < m - c - 1; i++) {
                ans.push_back(matrix[i][n - c - 1]);
            }
            for (int j = n - c - 1; j > c; j--) {
                ans.push_back(matrix[m - 1 - c][j]);
            }
            for (int i = m - 1 - c; i > c; i--) {
                ans.push_back(matrix[i][c]);
            }
        }
        return ans;
    }
};
```

## 0058. Length of Last Word

> :green_circle:

给定字符串，由单词和字符串组成，返回最后一个单词的长度

### 方法

- 从后向前扫描，先跳过起始的空格，记录非空格的长度，再遇到空格时终止

```cpp
class Solution {
public:
    int lengthOfLastWord(string s) {
        int len = 0;
        for (int i = s.size() - 1; i >= 0; i--) {
            if (s[i] == ' ' && len == 0) continue;
            if (s[i] == ' ') break;
            len++;
        }
        return len;
    }
};
```

## 0064. Minimum Path Sum

> :orange_circle:

mxn的非负数网格，找到从左上角到达右下角的一条路径，其值最小。每次只能向右或者下移动一步

### 方法

- 方法一：DFS遍历所有路径，记录路径和，得到最小值。TLE
- 方法二：动态规划，`dp[i][j]`表示到达该位置的路径最小的值，从上方与左方的值取最小即可。T: O(mxn), S: O(mxn)

```cpp
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vector<vector<int>> dp(m, vector<int>(n, 0));
        dp[0][0] = grid[0][0];
        for (int i = 1; i < m; i++) {
            dp[i][0] += dp[i - 1][0] + grid[i][0];
        }
        for (int j = 1; j < n; j++) {
            dp[0][j] += dp[0][j - 1] + grid[0][j];
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j];
            }
        } 
        return dp[m - 1][n - 1];
    }
};
```

## 0067. Add Binary

> :green_circle:

给两个二进制字符串，以二进制字符串的形式返回他们的和。`1 <= a.length, b.length <= 10^4`

### 方法

- 二进制字符串的长度最大为10^4，将其转为数值进行加和是不可能的。通过二进制位加和规则直接对字符串加和。T: O(L), S: O(L)
- 记录进位状态。根据进位状态，当前相加的二进制位，更新结果以及进位状态：结果为`carry % 2`，进位为`carry / 2`。

```cpp
class Solution {
public:
    string addBinary(string a, string b) {
        string res;
        int m = a.size(), n = b.size();
        int carry = 0;
        for (int i = 0; i < max(m, n); i++) {
            if (i < m) carry += a[m - 1 - i] - '0';
            if (i < n) carry += b[n - 1 - i] - '0';
            res = to_string(carry % 2) + res;
            carry = carry / 2;
        }
        if (carry == 1) res = "1" + res;
        return res;
    }
};
```

## 0079. Word Search

> :orange_circle:

给一个二维格子和字符串，判断字符串是否在二维格子中出现

### 方法

- 二维格子的DFS搜索。从每个格子出发，向四周进行搜索，一旦匹配全部字符串，立即返回true停止搜索。T: O(mn), S: O(mn)
- visited数组记录当前路径已经访问过的点，防止重复访问，通过直接设置`board[i][j]='*'`更节省空间
- 在进入每次搜索之前进行条件判断，是否满足要求，可以更早结束搜索，对BFS尤其优化明显

```cpp
class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        int m = board.size(), n = board[0].size();
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                visited = vector<vector<bool>>(m, vector<bool>(n, false));
                visited[i][j] = true;
                if (search(board, word, 0, i, j)) return true;
            }
        }
        return false;
    }
private:
    vector<vector<bool>> visited;
    int direc[5] = {1, 0, -1, 0, 1}; 
    bool search(vector<vector<char>>& board, string word, int step, int row, int col) {
        if (board[row][col] != word[step]) return false;
        if (step == word.size() - 1) return true;

        for (int i = 0; i < 4; i++) {
            int newRow = row + direc[i], newCol = col + direc[i + 1];
            if (newRow < 0 || newCol < 0 || newRow >= board.size() || newCol >= board[0].size()) continue;
            if (visited[newRow][newCol]) continue;
            visited[newRow][newCol] = true;
            if (search(board, word, step + 1, newRow, newCol)) return true;
            visited[newRow][newCol] = false;
        }
        return false;
    }
};
```

## 0088. Merge Sorted Array

> :green_circle:

给定两个非减数组nums1和nums2，元素数为m和n。将其合并为一个有序数组，并保存到nums1中，nums1的长度为m+n

### 方法

- nums1后部分有n个0，因此可以逆序合并，从数组的最右侧开始。最后nums2有剩余，则复制到nums1中。T: O(m + n), S: O(1)

```cpp
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int p1 = m - 1, p2 = n - 1;
        int index = m + n - 1;
        while (p1 >= 0 && p2 >= 0) {
            if (nums1[p1] >= nums2[p2]) {
                nums1[index--] = nums1[p1--]; 
            } else {
                nums1[index--] = nums2[p2--]; 
            }
        }
        while (p2 >= 0) nums1[index--] = nums2[p2--];
    }
};
```

## 0091. Decode Ways

> :orange_circle:

字母A-Z对应数字1-26。给一个由数字组成的字符串，求有几种解码的方式。注意"01"与“1”不同，不能解码为A

### 方法

- 动态规划，dp[i]代表s[0, i) 的解码方式，其由前一位或者前两位的值计算而来（可空间优化）。T: O(n), S: O(n)

```cpp
class Solution {
public:
    int numDecodings(string s) {
        if (s[0] == '0') return 0;
        int n = s.size();
        vector<int> dp(n + 1);
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 1; i < n; i++) {
            if (s[i] != '0') dp[i + 1] += dp[i];
            if (s[i - 1] == '1' || (s[i - 1] == '2' && s[i] <= '6')) {
                dp[i + 1] += dp[i - 1];
            }
        }
        return dp[n];
    }
};
```

## 0100. Same Tree

给两个二叉树的根节点，判断两个树是否相同（树的结构以及节点值相同）

### 方法一

- 递归，左子树及右子树相同，当前节点值相同，则两个树相同。T: O(n), S: O(n)

```cpp
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if (p == NULL && q == NULL) return true;
        if (p == NULL || q == NULL) return false;
        return p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
    }
};
```

### 方法二

- 迭代法，使用层序遍历，将两个树的节点依次加入队列进行判断。T: O(n), S: O(n)

```cpp
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        queue<TreeNode*> que;
        que.push(p);
        que.push(q);
        while (!que.empty()) {
            p = que.front(); que.pop();
            q = que.front(); que.pop();
            if (p == NULL && q == NULL) continue;
            if (p == NULL || q == NULL) return false;
            if (p->val != q->val) return false;
            que.push(p->left);
            que.push(q->left);
            que.push(p->right);
            que.push(q->right);
        }
        return true;
    }
};
```

## 0103. Binary Tree Zigzag Level Order Traversal

> :orange_circle:

二叉树的锯齿形层序遍历。从左到右，下一行从右到左，交替进行

### 方法一

- 层序遍历，单向队列，用数组记录每层的数值，将需要逆序的层的数组reverse即可
- 或者根据是否逆序直接插入到正确的数组位置，比reverse性能更好

```cpp
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> res;
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        int layer = 0;
        while (!que.empty()) {
            int size = que.size();
            vector<int> ans(size);
            for (int i = 0; i < size; i++) {
                TreeNode* cur = que.front();
                que.pop();
                if (layer % 2 == 0) ans[i] = cur->val;
                else ans[size - 1 - i] = cur->val;
                if (cur->left) que.push(cur->left);
                if (cur->right) que.push(cur->right);
            }
            layer++;
            res.push_back(ans);
        }
        return res;
    }
};
```

### 方法二

- 层序遍历，方法一并没有真正锯齿形遍历，而只是将结果改变到了正确顺序

- 采用双向队列实现锯齿形遍历，保持队列节点的有序性，读取和插入根据顺序改变

```cpp
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> res;
        deque<TreeNode*> que;
        if (root != NULL) que.push_front(root);
        bool leftToRight = true;
        while (!que.empty()) {
            int size = que.size();
            vector<int> ans(size);
            for (int i = 0; i < size; i++) {
                if (leftToRight) {
                    TreeNode* cur = que.front();
                    que.pop_front();
                    ans[i] = cur->val;
                    if (cur->left) que.push_back(cur->left);
                    if (cur->right) que.push_back(cur->right);
                } else {
                    TreeNode* cur = que.back();
                    que.pop_back();
                    ans[i] = cur->val;
                    if (cur->right) que.push_front(cur->right);
                    if (cur->left) que.push_front(cur->left);
                }
            }
            leftToRight = !leftToRight;
            res.push_back(ans);
        }
        return res;
    }
};
```

## 0104. Maximum Depth of Binary Tree

> :green_circle:

给一个二叉树根节点，返回最大深度。最大深度是根节点到最远的叶节点的路径上的节点数目

### 方法

- 二叉树深度：根节点至当前节点，二叉树高度：当前节点至叶子结点
- 迭代法层序遍历，记录层数。递归法后序遍历，（左右中）求深度，选取左右子树的最大深度，然后加1继续向上。

```cpp
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (root == NULL) return 0;
        return max(maxDepth(root->left), maxDepth(root->right)) + 1;
    }
};
```

## 0106. Construct Binary Tree from Inorder and Postorder Traversal

> :orange_circle:

给两个整数数组分别是中序遍历和后序遍历，构建二叉树

### 方法

- 中序遍历为 [左中右]，后序遍历为[左右中]，根据"中"建立根节点，并划分数组，递归建立左右节点
- 可以用map提前存储每个节点的位置，省去遍历查找的时间

```cpp
class Solution {
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        return build(inorder, postorder, 0, inorder.size() - 1, 0, postorder.size() - 1);
    }
private:
    TreeNode* build(vector<int>& inorder, vector<int>& postorder, int sIn, int eIn, int sPost, int ePost) {
        if (sPost > ePost) return NULL;
        TreeNode* root = new TreeNode(postorder[ePost]);
        if (sPost == ePost) return root;
        for (int i = sIn; i <= eIn; i++) {
            if (inorder[i] == postorder[ePost]) {
                root->left = build(inorder, postorder, sIn, i - 1, sPost, sPost + i - 1 - sIn);
                root->right = build(inorder, postorder, i + 1, eIn, sPost + i - sIn, ePost - 1);
                break;
            }
        }
        return root;
    }
};
```

## 0109. Convert Sorted List to Binary Search Tree

> :orange_circle:

给一个单向链表，元素是升序排列的。将其转换为高度平衡的二叉搜索树

### 方法

- 将链表的元素值存入数组。传入数组下标构建BST，中间位置做根节点，递归构建左右子树
- 可以通过快慢指针遍历链表，得到中间节点，传入链表头尾节点构建BST

```cpp
class Solution {
public:
    TreeNode* sortedListToBST(ListNode* head) {
        vector<int> vals;
        while (head) {
            vals.push_back(head->val);
            head = head->next;
        }
        return buildBST(vals, 0, vals.size() - 1);
    }
private:
    TreeNode* buildBST(vector<int>& vals, int s, int e) {
        if (s > e) return NULL;
        int m = s + (e - s) / 2;
        TreeNode* cur = new TreeNode(vals[m]);
        if (s == e) return cur;
        cur->left = buildBST(vals, s, m - 1);
        cur->right = buildBST(vals, m + 1, e);
        return cur;
    }
};
```

## 0129. Sum Root to Leaf Numbers

> :orange_circle:

二叉树节点值都是0-9，从根到叶节点的路径代表一个数字，返回数字的和

### 方法

- DFS遍历二叉树得到每条路径，递归法返回数值，进行加和计算。T: O(N), S: O(H)

```cpp
class Solution {
public:
    int sumNumbers(TreeNode* root) {
        return dfs(root, 0);
    }
private:
    int dfs(TreeNode* node, int cnt) {
        if (!node) return 0;
        cnt = cnt * 10 + node->val;
        if (!node->left && !node->right) {
            return cnt;
        }
        return dfs(node->left, cnt) + dfs(node->right, cnt);
    }
};
```

## 0131. Palindrome Partitioning

> :orange_circle:

划分字符串，使得每个子串是回文的。返回所有可能的划分方式

### 方法

- 回溯算法，DFS遍历每个划分位置，判断得到的每个子串是否是回文的

```cpp
class Solution {
public:
    vector<vector<string>> partition(string s) {
        res.clear();
        path.clear();
        backstracking(s, 0);
        return res;
    }
    
private:
    vector<vector<string>> res;
    vector<string> path;
    void backstracking(string s, int startIndex) {
        if (startIndex == s.size()) {
            res.push_back(path);
            return;
        }
        
        for (int i = startIndex; i < s.size(); i++) {
            string str = s.substr(startIndex, i - startIndex + 1);
            if (!isPalindrome(str)) continue;
            path.push_back(str);
            backstracking(s, i + 1);
            path.pop_back();
        }
    }
    
    bool isPalindrome(string s) {
        for (int i = 0; i < s.size(); i++) {
            if (s[i] != s[s.size() - 1 - i]) {
                return false;
            }
        }
        return true;
    }
};
```

## 0138. Copy List with Random Pointer

> :orange_circle:

有序链表，节点包含额外的随机指针，指向链表中的任一节点或NULL。复制该有序链表

### 方法

- 先根据next指针建立新的链表，然后再确定每个节点的random指针（从头搜索）。T: O(n^2), S: O(1)

```cpp
class Solution {
public:
    Node* copyRandomList(Node* head) {
        if (head == NULL) return head;
        Node *newHead = new Node(head->val);
        Node *p1 = head, *p2 = newHead;
        while (p1->next) {
            p1 = p1->next;
            p2->next = new Node(p1->val);
            p2 = p2->next;
        }
        p1 = head, p2 = newHead;
        while (p1) {
            if (p1->random == NULL) {
                p2->random = NULL;
            } else {
                Node *p3 = head, *p4 = newHead;
                while (p3 != p1->random) {
                    p3 = p3->next;
                    p4 = p4->next;
                }
                p2->random = p4;
            }
            p1 = p1->next;
            p2 = p2->next;
        }
        return newHead;
    }
};
```

## 0149. Max Points on a Line

> :red_circle:

给一个数组， `points[i] = [xi, yi]`代表二维平面上的点，返回在同一条直线上的最多的点的数量

### 方法

- 对于每一个点，计算其它所有点与该点形成的角度，用map统计数量，得到点最多的直线。T: O(n^2), S: O(n)

```cpp
class Solution {
public:
    int maxPoints(vector<vector<int>>& points) {
        int n = points.size();
        if (n == 1) return 1;
        int ans = 2;
        for (int i = 0; i < n; i++) {
            unordered_map<double, int> cnt;
            for (int j = 0; j < n; j++) {
                if (j != i) {
                    cnt[atan2(points[j][1] - points[i][1], points[j][0] - points[i][0])]++;
                }
            }
            for (auto& [h, count] : cnt) {
                ans = max(ans, count + 1);
            }
        } 
        return ans;
    }
};
```

## 0152. Maximum Product Subarray

给一个整数数组，找到有最大乘积的子数组，返回乘积。`1 <= nums.length <= 2 * 10^4; -10 <= nums[i] <= 10`

### 方法

- 计算前缀乘积，计算后缀乘积，记录最大值。遇到0重新计算，即按照0进行分割。T: O(n), S: O(1)

```cpp
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int n = nums.size(), l = 0, r = 0, res = nums[0];
        for (int i = 0; i < n; i++) {
            l = (l ? l : 1) * nums[i];
            r = (r ? r : 1) * nums[n - i - 1];
            res = max({res, l, r});
        }
        return res;
    }
};
```

## 0168. Excel Sheet Column Title

> :green_circle:

给定一个数字，返回其对应的Excel表的列名称。`1->A,2->B...26->Z,27->AA,28->AB...`

### 方法

- 字母26个，26个一轮，因此对26取余，除以26
- Excel中A从1开始，且27是AA，每次n要减1。`ABZ: n = (A+1) * 26^2 + (B+1) * 26^1 + (Z+1) * 26^0`
- `string.insert(pos, str), string.insert(pos, n, char), string.insert(pos, str, pos1, n)`

```cpp
class Solution {
public:
    string convertToTitle(int columnNumber) {
        string res;
        while (columnNumber) {
            columnNumber--;
            res.insert(0, 1, columnNumber % 26 + 'A');
            columnNumber /= 26;
        }
        return res;
    }
};
```

## 0208. Implement Trie (Prefix Tree)

> :orange_circle:

实现前缀树，其对字符串集合进行高效存储和检索。字符串都是小写英文

### 方法

- 每个节点有26个孩子，并标记到该节点是否是单词。使用数组或者map存储孩子

```cpp
class Trie {
public:
    Trie() {}

    void insert(string word) {
        Trie* node = this;
        for (char ch : word) {
            ch -= 'a';
            if (!node->next[ch]) { node->next[ch] = new Trie(); }
            node = node->next[ch];
        }
        node->isword = true;
    }

    bool search(string word) {
        Trie* node = this;
        for (char ch : word) {
            ch -= 'a';
            if (!node->next[ch]) { return false; }
            node = node->next[ch];
        }
        return node->isword;
    }

    bool startsWith(string prefix) {
        Trie* node = this;
        for (char ch : prefix) {
            ch -= 'a';
            if (!node->next[ch]) { return false; }
            node = node->next[ch];
        }
        return true;
    }

private:
    Trie* next[26] = {};
    bool isword = false;
};
```

## 0211. Design Add and Search Words Data Structure

> :orange_circle:

设计数据结构，能够添加新的字符串，并查找字符串。添加的字符串全为小写字母组成，查找的字符串包含通配符`'.'`

### 方法

- 使用Trie树存储字符串，并利于高效查找。遇到通配符时，进行DFS搜索所有可能。

<!--tab: start-->

####First

```cpp
class WordDictionary {
public:
    WordDictionary() {
        
    }
    
    void addWord(string word) {
        // cout << "a: null " << word << endl;
        WordDictionary* cur = this;
        for (char c : word) {
            int i = c - 'a';
            if (!cur->next[i]) cur->next[i] = new WordDictionary();
            cur = cur->next[i];
        }
        cur->end = true;
    }
    
    bool search(string word) {
        bool res = dfs(this, word, 0);
        // cout << "s: " << res << " "<< word << endl;
        return res;
    }

    bool dfs(WordDictionary* cur, string& word, int index) {
        int n = word.size();
        if (word[index] == '.') {
            for (int j = 0; j < 26; j++) {
                if (cur->next[j]) {
                    if (index == n - 1) {
                        if (cur->next[j]->end) return true; //此处不可直接返回，只有为true时返回
                    }
                    else if (dfs(cur->next[j], word, index + 1)) return true;
                }
            }
            return false;
        } else {
            int j = word[index] - 'a';
            if (!cur->next[j]) return false;
            cur = cur->next[j];
            if (index == n - 1) return cur->end;
            return dfs(cur, word, index + 1);
        }
    }

private:
    bool end = false;
    WordDictionary* next[26] = {};
};
```

####Second

```cpp
class WordDictionary {
public:
    WordDictionary() {
        
    }
    
    void addWord(string word) {
        WordDictionary* cur = this;
        for (char c : word) {
            int i = c - 'a';
            if (!cur->next[i]) cur->next[i] = new WordDictionary();
            cur = cur->next[i];
        }
        cur->end = true;
    }
    
    bool search(string word) {
        WordDictionary* cur = this;
        for (int i = 0; i < word.size(); i++) {
            char c = word[i];
            if (c == '.') {
                for (auto ch : cur->next) {
                    if (ch && ch->search(word.substr(i + 1))) {
                        return true;
                    }
                }
                return false;
            }
            if (!cur->next[c - 'a']) return false;
            cur = cur->next[c - 'a'];
        }
        return cur && cur->end;
    }

private:
    bool end = false;
    WordDictionary* next[26] = {};
};
```

<!--tab: end-->

## 0223. Rectangle Area

> :orange_circle:

在2维平面上，给出两个矩形左下角和右上角的坐标，计算两个矩形覆盖的面积（可能有重叠）

### 方法

- 先计算出两个矩形的面积，再减去重叠部分的面积。根据坐标大小依次定位重叠部分的四个坐标。T: O(1), S: O(1)

```cpp
class Solution {
public:
    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {
        int area = (bx2 - bx1) * (by2 - by1) + (ax2 - ax1) * (ay2 - ay1);
        if (bx1 >= ax2 || bx2 <= ax1 || by2 <= ay1 || by1 >= ay2) return area;
        int cx1, cy1, cx2, cy2;
        cx1 = bx1 > ax1 ? bx1 : ax1;
        cx2 = bx2 > ax2 ? ax2 : bx2;
        cy1 = by1 > ay1 ? by1 : ay1;
        cy2 = by2 > ay2 ? ay2 : by2;
        int overlap = (cx2 - cx1) * (cy2 - cy1);
        return area - overlap;
    }
};
```

## 0224. Basic Calculator

> :red_circle:

字符串代表一个有效的表达式，计算结果。字符串中包含`+ - ( )`和 `' '`

### 方法

- 设置全局的结果和符号，进行逐步计算。使用栈处理括号的情况
- 遇到数字时，取出所有相连的数字，如`23`，然后进行计算。注意先加时可能溢出`num = num * 10 + s[i++] - '0';`
- 遇到左括号时，将当前的值和符号加入栈中保存`3+(1+..`。遇到右括号时，取出栈中保存的数进行计算`() +3`。

```cpp
class Solution {
public:
    int calculate(string s) {
        int sign = 1;
        int res = 0;
        stack<int> st;
        for (int i = 0; i < s.size(); i++) {
            if (isdigit(s[i])) {
                int num = 0;
                while (i < s.size() && isdigit(s[i])) {
                    num = num * 10 + (s[i++] - '0');
                }
                i--;
                res += num * sign;
                sign = 1;
            } else if (s[i] == '+') {
                sign = 1;
            } else if (s[i] == '-') {
                sign = -1;
            } else if (s[i] == '(') {
                st.push(res);
                st.push(sign);
                res = 0;
                sign = 1;
            } else if (s[i] == ')') {
                res *= st.top();
                st.pop();
                res += st.top();
                st.pop();
            }
        }
        return res;
    }
};
```

## 0226. Invert Binary Tree

> :green_circle:

- 给二叉树的根节点，翻转二叉树，返回根节点

### 方法

- 迭代法层序遍历，翻转每个节点的左右子节点。T: O(n), S: O(n)
- 递归三部曲：递归函数参数及返回值，终止条件，单层递归逻辑。递归前序遍历，翻转当前节点的左右子节点，然后向下翻转

```cpp
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        invert(root);
        return root;
    }
private:
    void invert(TreeNode* root) {
        if (root == NULL) return;
        swap(root->left, root->right);
        invert(root->left);
        invert(root->right);
    }
};
```

## 0227. Basic Calculator II

> :orange_circle:

给表达式字符串，计算表达式的值。字符串由数字，`+ - * / `以及空格组成

### 方法一

- 乘除法具有较高优先级，可直接计算，而加减法必须下一个运算符也是加减才能计算
- 使用栈存储数字，记录当前的数字以及前一个操作符，遇到新的操作符时计算前一个操作符。T: O(n), S: O(n)

```cpp
class Solution {
public:
    int calculate(string s) {
        stack<int> st;
        int num = 0;
        char op = '+';
        for (int i = 0; i < s.size(); i++) {
            if (isdigit(s[i])) {
                num = num * 10 + (s[i] - '0');
            } 
            if ((!isdigit(s[i]) && s[i] != ' ') || i == s.size() - 1) {
                if (op == '-') num = -num;
                else if (op == '*') {
                    num = st.top() * num;
                    st.pop();
                } else if (op == '/'){
                    num = st.top() / num;
                    st.pop();
                }
                st.push(num);
                op = s[i];
                num = 0;
            }
        }
        int res = 0;
        while (!st.empty()) {
            res += st.top();
            st.pop();
        }
        return res;
    }
};
```

### 方法二

- 在方法一使用栈的基础上，记录结果及栈顶数字，从而优化空间。T: O(n), S: O(1)

```cpp
class Solution {
public:
    int calculate(string s) {
        int num = 0, lastNum = 0, ans = 0;
        char op = '+';
        for (int i = 0; i < s.size(); i++) {
            if (isdigit(s[i])) {
                num = num * 10 + (s[i] - '0');
            } 
            if ((!isdigit(s[i]) && s[i] != ' ') || i == s.size() - 1) {
                if (op == '+' || op == '-') {
                    ans += lastNum;
                    lastNum = (op == '+') ? num : -num;
                }
                else if (op == '*') {
                    lastNum *= num;
                } else if (op == '/'){
                    lastNum /= num;
                }
                op = s[i];
                num = 0;
            }
        }
        ans += lastNum;
        return ans;
    }
};
```

## 0238. Product of Array Except Self

> :orange_circle:

给一个整数数组，返回答案数组，每个位置的值等于除自己外整数数组所有元素的乘积。要求时间O(n)，不使用除法

Follow Up: O(1)  额外空间（输出数组不计算空间复杂度）

### 方法

- 计算前缀乘积与后缀乘积，更新到结果数组中即可，可以简化为一遍遍历。T: O(n), S: O(1)

```cpp
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, 1);
        for (int i = 1; i < n; i++) {
            ans[i] = ans[i - 1] * nums[i - 1];
        }
        int right = 1;
        for (int i = n - 2; i >= 0; i--) {
            right *= nums[i + 1];
            ans[i] *= right;
        }
        return ans;
    }
};
```

## 0263. Ugly Number

> :green_Circle:

丑数是正整数，主要因子是2，3，5。1没有主要因子，也是丑数。判断给的数n是否是丑数，`-2^31 <= n <= 2^31 - 1`

### 方法

- 丑数是正数，且因子是固定的数，因此可以将其一直除以因子，最后一定得到1

```cpp
class Solution {
public:
    bool isUgly(int n) {
        while (n) {
            if (n == 1) return true;
            else if (n % 2 == 0) n /= 2;
            else if (n % 3 == 0) n /= 3;
            else if (n % 5 == 0) n /= 5;
            else return false;
        }
        return false;
    }
};
```

## 0264. Ugly Number II

> :orange_circle:

丑数是主要因子为2，3，5的正整数，从1开始。返回第n个丑数，`1 <= n <= 1690`

### 方法一

- 从最小的1开始，每次乘以2，3，5即可得到之后的丑数，但顺序不确定，如`1*5 > 2*2`，且有重复`2*3 = 3*2`
- 为了每次得到最小的丑数，可以使用小顶堆，且堆顶等于之前取出的元素时，有重复。数据较大有溢出，使用long

```cpp
class Solution {
public:
    int nthUglyNumber(int n) {
        priority_queue<long, vector<long>, greater<long>> que;
        que.push(1);
        long res = 0;
        while (n--) {
            while (!que.empty() && res == que.top()) que.pop();
            res = que.top();
            que.pop();
            que.push(res * 2);
            que.push(res * 3);
            que.push(res * 5);
        }
        return res;
    }
};
```

### 方法二

- 动态规划，使用三个指针分别指向要乘以2，3，5的数，dp数组每次取最小值，并更新相应的指针。
- 有重复数时，两个指针都会移动。如`2*3 = 3*2`，此时指针2和3都会移动，可以去重。T: O(n), S: O(n)

```cpp
class Solution {
public:
    int nthUglyNumber(int n) {
        vector<int> dp(n);
        dp[0] = 1;
        int p2 = 0, p3 = 0, p5 = 0;
        for (int i = 1; i < n; i++) {
            dp[i] = min({dp[p2] * 2, dp[p3] * 3, dp[p5] * 5});
            if (dp[i] == dp[p2] * 2) p2++;
            if (dp[i] == dp[p3] * 3) p3++;
            if (dp[i] == dp[p5] * 5) p5++;
        }
        return dp[n - 1];
    }
};
```

## 0268. Missing Number

> :green_circle:

给一个数组包含n个独特的数，范围是[0,n]，找到唯一一个缺失的数。

Follow up: O(1)额外空间，O(n)时间复杂度

### 方法一

- 将数组排序，遍历查找（O(n)）缺失的数。T: O(nlogn), S: O(logn)

```cpp
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] != i) return i;
        }
        return nums.size();
    }
};
```

### 方法二

- 假定数组有序的情况下，可以二分查找（O(logn)）缺失的数。T: O(nlogn), S: O(logn)
- 一定有`nums[mid] >= mid`，大于代表缺失在数组的前半部分，等于代表在后半部分
- 左闭右开区间：`j = nums.size(), while (i < j), j = mid  `，最后`i==j`  ，返回i或j均可
- 左闭右闭区间：`j = nums.size() - 1, while (i <= j), j = mid - 1`，最后`i = j + 1`，要返回i

<!-- tabs:start -->

####**First**

```cpp
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int i = 0, j = nums.size();
        while (i < j) {
            int mid = i + (j - i) / 2;
            if (nums[mid] == mid) i = mid + 1;
			else j = mid;
        }
        return j; // return i;
    }
};
```

####**Second**

```cpp
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int i = 0, j = nums.size() - 1;
        while (i <= j) {
            int mid = i + (j - i) / 2;
            if (nums[mid] == mid) i = mid + 1;
			else j = mid - 1;
        }
        return i;
    }
};
```

<!-- tabs:end -->

### 方法三

- 数组哈希，记录出现的数，遍历找到缺失的数。T: O(n), S: O(n)

```cpp
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int n = nums.size();
        vector<int> hash(n + 1, 0);
        for (int i : nums) hash[i] = 1;
        for (int i = 0; i < n + 1; i++) {
            if (hash[i] == 0) return i;
        }
        return -1;
    }
};
```

### 方法四

- 求和，总和减去数组的和，即为缺失的数。T: O(n), S: O(1)

```cpp
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int n = nums.size();
        int sum = (0 + n) * (n + 1) / 2;
        for (int num : nums) sum -= num;
        return sum;
    }
};
```

### 方法五

- 位操作，异或，有性质`a ^ 0 = a, a ^ a = 0, a ^ b ^ b = a`，将下标`[0, n]`与数值一起异或，最后剩余的即为缺失的数值。T: O(n), S: O(1)

```cpp
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int res = nums.size();
        for (int i = 0; i < nums.size(); i++) {
            res = res ^ i ^ nums[i];
        }
        return res;
    }
};
```

## 0287. Find the Duplicate Number

> :orange_circle:

整数数组有n+1个数，取值范围为[1, n]，只有一个重复数字，找出该数字。不能修改数组，使用常量空间。

Follow up: 如何证明一定存在至少一个重复数字，线性时间复杂度

### 方法一

- Negative Marking，通过负数标记判断是否有重复数字，将`|num|`位置的数标记为负数，若标记前为负数则该数重复。该方法修改了数组，不满足题意。T: O(n), S: O(1)

```cpp
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int ans = -1;
        for (int i = 0; i < nums.size(); i++) {
            int n = abs(nums[i]);
            if (nums[n] < 0) {
                ans = n;
                break;
            }
            nums[n] *= -1;
        }
        for (int& n : nums) n = abs(n);
        return ans;
    }
};
```

### 方法二

- 数值取值范围为[1, n]，将每个数映射到其下标，没有数能映射到下标0。从下标0开始，不断映射，最后下标0的数即为重复。T: O(n), S: O(1)

```cpp
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        while (nums[0] != nums[nums[0]]) {
            swap(nums[0], nums[nums[0]]);
        }
        return nums[0];
    }
};
```

### 方法三

- 将该问题视为链表的环检测问题（检测环入口），采用快慢指针，快指针是慢指针速度的两倍。T: O(n), S: O(1)
- Floyd's Tortoise and Hare：第一阶段：兔是龟速度的两倍，直至相遇；第二阶段：减慢兔子速度，龟从头出发，直至相遇

```cpp
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int tortoise = nums[0], hare = nums[0];
        do {
            tortoise = nums[tortoise];
            hare = nums[nums[hare]];
        } while (tortoise != hare);
        tortoise = nums[0];
        while (hare != tortoise) {
            tortoise = nums[tortoise];
            hare = nums[hare];
        }
        return tortoise;
    }
};
```

## 0290. Word Pattern

> :green_cicle:

字符串`pattern`和`s`，判断`s`是否满足模式：模式的字母与`s`中的单词一一对应。都由小写字母组成，s中的单词由单个空格分割

### 方法

- 采用两个map分别映射字母与单词（可将其映射为同一个数），注意长度不同时也为false。T: O(n), S: O(n)

```cpp
class Solution {
public:
    bool wordPattern(string pattern, string s) {
        unordered_map<char, int> p2i;
        unordered_map<string, int> w2i;
        istringstream in(s);
        int i = 0, n = pattern.size();
        for (string w; in >> w; i++) {
            if (i == n || p2i[pattern[i]] != w2i[w]) return false;
            p2i[pattern[i]] = w2i[w] = i + 1;
        }
        return i == n;
    }
};
```

## 0295. Find Median from Data Stream

> :red_circle:

实现中位数寻找类，数据流不断输入整数，实现添加数据和查找中位数方法

### 方法一

- 维护有序数组，添加元素时通过二分查找确定添加位置O(logn)，查找中位数时根据数组大小直接计算O(1)
- （TLE）实际上vector的insert操作是O(n)时间复杂度。添加: O(n), 查找: O(1)，S: O(n)

```cpp
class MedianFinder {
public:
    MedianFinder() {
        
    }
    
    void addNum(int num) {
        int left = 0, right = nums.size() - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < num) left = mid + 1;
            else if (nums[mid] > num) right = mid - 1;
            else {
                nums.insert(nums.begin() + mid, num);
                return;
            }
        }
        nums.insert(nums.begin() + left, num);
    }
    
    double findMedian() {
        int size = nums.size();
        if (size % 2 == 0) return (nums[size / 2] + nums[size / 2 - 1]) / 2.0;
        else return nums[size / 2];
    }
private:
    vector<int> nums;
};
```

### 方法二

- 大顶堆存储一半小数据，小顶堆存储一半大数据，可以O(1)找到中位数。添加O(logn)，查找O(1)，S: O(n)
- 添加数据时需要保证两个堆的大小平衡，偶数时两个堆数量一样，奇数时大顶堆多一个数
- 先将数据加入大顶堆，再把最大的移向小顶堆，如果小顶堆元素多，再移向大顶堆（可以通过更详细的判断进行优化）

<!-- tabs:start -->

####**First**

```cpp
class MedianFinder {
public:
    priority_queue<int> maxHeap;
    priority_queue<int, vector<int>, greater<int>> minHeap; 
    MedianFinder() {
    }
    void addNum(int num) {
        maxHeap.push(num);
        minHeap.push(maxHeap.top());
        maxHeap.pop();
        if (minHeap.size() > maxHeap.size()) {
            maxHeap.push(minHeap.top());
            minHeap.pop();
        }
    }
    double findMedian() {
        if (maxHeap.size() > minHeap.size()) return maxHeap.top();
        else return (maxHeap.top() + minHeap.top()) / 2.0;
    }
};
```

####**Second**

```cpp
class MedianFinder {
public:
    priority_queue<int> maxHeap;
    priority_queue<int, vector<int>, greater<int>> minHeap; 
    MedianFinder() {   
    }
    void addNum(int num) {
        if (maxHeap.size() == 0 || num < maxHeap.top()) {
            maxHeap.push(num);
            if (maxHeap.size() > minHeap.size() + 1) {
                minHeap.push(maxHeap.top());
                maxHeap.pop();
            }
        }
        else {
            minHeap.push(num);
            if (minHeap.size() > maxHeap.size()) {
                maxHeap.push(minHeap.top());
                minHeap.pop();
            }
        } 
    }
    double findMedian() {
        if (maxHeap.size() > minHeap.size()) return maxHeap.top();
        else return (maxHeap.top() + minHeap.top()) / 2.0;
    }
};
```

<!-- tabs:end -->

## 0328. Odd Even Linked List

> :orange_circle:

单链表，将其按照下标的奇偶划分为两组（第一个下标为奇），奇在前偶在后，返回新的链表。要求O(1)空间O(n)时间

### 方法

- 类似拆分链表，分别记录奇数下标链表，与偶数下标链表，最后合并。T: O(n), S: O(1)

```cpp
class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {
        ListNode *oddHead = new ListNode();
        ListNode *evenHead = new ListNode();
        ListNode *p1 = oddHead, *p2 = evenHead;
        int size = 1;
        ListNode *cur = head;
        while (cur) {
            if (size % 2 == 1) {
                p1->next = cur;
                p1 = p1->next;
            } else {
                p2->next = cur;
                p2 = p2->next;
            }
            size++;
            cur = cur->next;
        }
        p2->next = nullptr;
        p1->next = evenHead->next;
        return oddHead->next;
    }
};
```

## 0345. Reverse Vowels of a String

> :green_circle:

给定字符串，将其中的元音字母进行反转。元音字母是`a e i o u`，可能小写或者大写，且多次出现

### 方法

-  双指针，左右指针的元音字母进行交换。T: O(n), S: O(1)

```cpp
class Solution {
public:
    string reverseVowels(string s) {
        int left = 0, right = s.size() - 1;
        unordered_set<char> set({'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'});
        while (left < right) {
            while (left < s.size() && set.find(s[left]) == set.end()) left++;
            while (right >= 0 && set.find(s[right]) == set.end()) right--;
            if (left < right) {
                swap(s[left++], s[right--]);
            }
        }
        return s;
    }
};
```

## 0352. Data Stream as Disjoint Intervals

> :orange_circle:

输入非负整数的数据流，实现数据结构，返回每个数据区间的起始和终止位置，答案按照起始数字排序

### 方法

- 数据流插入数据时，维护数据的有序性，然后遍历查找每个区间。T: O(logN) for `addNum`, O(N) for `getIntervals`, S: O(N)

```cpp
class SummaryRanges {
public:
    SummaryRanges() {
        
    }
    
    void addNum(int value) {
        values.insert(value);
    }
    
    vector<vector<int>> getIntervals() {
        vector<vector<int>> ans;
        if (values.size() == 0) return ans;
        int left = -1, right = -1;
        for (int value : values) {
            if (left < 0) {
                left = right = value;
            } else if (value == right + 1) {
                right = value;
            } else {
                ans.push_back({left, right});
                left = right = value;
            }
        }
        ans.push_back({left, right});
        return ans;
    }
private:
    set<int> values;
};
```

## 0374. Guess Number Higher or Lower

> :green_circle:

猜数字游戏。1~n中挑选一个数，猜出该数的大小。可以调用guess函数，-1猜的大，1猜的小，0猜对了

### 方法

- 二分查找，每次取中间，根据猜的结果调整左右边界。T: O(logn), S: O(1)

```cpp
class Solution {
public:
    int guessNumber(int n) {
        int left = 0, right = n;
        int mid;
        while (true) {
            mid = left + (right - left) / 2;
            int res = guess(mid);
            if (res == -1) right = mid - 1;
            else if (res == 1) left = mid + 1;
            else break;
        }
        return mid;
    }
};
```

## 0382. Linked List Random Node

> :orange_circle:

给一个单链表，随机返回其中的节点值，每个节点被选中的概率相同

### 方法一

- 遍历整个链表，记录节点个数以及每个节点值，随机数选择节点。T: O(n), S: O(n)

```cpp
class Solution {
public:
    Solution(ListNode* head) {
        ListNode* cur = head;
        while (cur) {
            vals.push_back(cur->val);
            cur = cur->next;
        }
    }
    
    int getRandom() {
        int id = rand() % vals.size();
        return vals[id];
    }
private:
    vector<int> vals;
};
```

### 方法二

- Reservoir Sampling，从n个数中选择k个，每个数的概率是k/n。先选前k个放入池子，对第k+i个元素，选取概率是k/k+i，并替换掉池子中的一个元素。此题中k=1。T: O(n), S:O(1)

```cpp
class Solution {
public:
    Solution(ListNode* head) {
        node = head;
    }
    
    int getRandom() {
        int ans = 0, i = 1;
        ListNode* p = node;
        while (p) {
            if (rand() % i == 0) ans = p->val;
            i++;
            p = p->next;
        }
        return ans;
    }
private:
    ListNode* node; 
};
```

## 0394. Decode String

> :orange_circle:

给一个编码字符串，将其解码。编码规则为`k[encoded_string]`，表示k个重复子串

### 方法

- 采用栈存储，遇到数字取出后续数字，遇到字符串取出后续字符串，遇到“[”直接入栈，遇到"]"开始处理
- 注意，读到字符串或者处理完字符串时，需要与栈顶的字符串合并

```cpp
class Solution {
public:
    string decodeString(string s) {
        stack<string> st;
        for (int i = 0; i < s.size(); i++) {
            if (isdigit(s[i])) {
                int j = i + 1;
                while (j < s.size() && isdigit(s[j])) j++;
                st.push(s.substr(i, j - i));
                i = j - 1;
            } else if (s[i] == '[') {
                st.push("[");
            } else {
                string res;
                if (isalpha(s[i])) {
                    int j = i + 1;
                    while (j < s.size() && isalpha(s[j])) j++;
                    res = s.substr(i, j - i);
                    i = j - 1;
                } else if (s[i] == ']'){
                    string str = st.top();
                    st.pop();
                    st.pop();
                    int k = stoi(st.top());
                    st.pop();
                    while (k--) res += str;
                }
                if (!st.empty() && st.top() != "[") {
                    res = st.top() + res;
                    st.pop();
                }
                st.push(res);
            }
        }
        return st.top();
    }
};
```

### 拓展

- isdigit()：数字；isalpha()：字母；islower(): 小写字母；isupper(): 大写字母；isalnum(): 数字或字母

## 0427. Construct Quad Tree

> :orange_circle:

nxn的矩阵，只有0和1，将其转换为Quad-Tree。每个树节点有两个属性val和isLeaf，有四个孩子节点。当前网格全0或全1，val为网格值，isLeaf为true，没有子节点。当前网格有不同值，val任意，isLeaf为false，有四个子节点。

### 方法一

- 递归建树，先遍历当前网格的值情况，确定当前节点的情况，然后确定子树的情况。

```cpp
class Solution {
public:
    Node* construct(vector<vector<int>>& grid) {
        return buildTree(grid, 0, grid.size(), 0, grid.size());
    }
private:
    Node* buildTree(vector<vector<int>>& grid, int rowL, int rowR, int colL, int colR) {
        int val = grid[rowL][colL];
        bool isLeaf = true;
        for (int i = rowL; i < rowR; i++) {
            for (int j = colL; j < colR; j++) {
                if (grid[i][j] != val) {
                    isLeaf = false;
                    break;
                }
            }
        }
        Node* root = new Node(val, isLeaf);
        if (!isLeaf) {
            int d = (rowR - rowL) / 2;
            root->topLeft = buildTree(grid, rowL, rowL + d, colL, colL + d);
            root->topRight = buildTree(grid, rowL, rowL + d, colL + d, colR);
            root->bottomLeft = buildTree(grid, rowL + d, rowR, colL, colL + d);
            root->bottomRight = buildTree(grid, rowL + d, rowR, colL + d, colR);
        }
        return root;
    }
};
```

### 方法二

- 分治策略，一直划分到单个网格，通过返回的子节点情况，确定父节点的情况。
- 通过起始点的横纵坐标以及网格的边长即可确定子网格的位置
- 叶节点只有两种，值为0或1，事先定义，可以减少使用的内存，并利于判断子节点情况

```cpp
class Solution {
public:
    Node* construct(vector<vector<int>>& grid) {
        leafNode[0] = new Node(false, true);
        leafNode[1] = new Node(true, true);
        return buildTree(grid, 0, 0, grid.size());
    }
private:
    array<Node*, 2> leafNode;
    Node* buildTree(vector<vector<int>>& grid, int r, int c, int s) {
        if (s == 1) return leafNode[grid[r][c]];
        s /= 2;
        Node* tl = buildTree(grid, r, c, s); 
        Node* tr = buildTree(grid, r, c + s, s); 
        Node* bl = buildTree(grid, r + s, c, s); 
        Node* br = buildTree(grid, r + s, c + s, s);
        if (tl == tr && tl == bl && tl == br) {
            return tl;
        }
        return new Node(false, false, tl, tr, bl, br);
    }
};
```

## 0433. Minimum Genetic Mutation

> :orange_circle:

基因字符串长度为8，由`A C G T`四种字符组成。可改变单个字符进行基因变异。给一个起始基因和一个终止基因，以及一个有效基因库`bank`，返回起始基因变异为终止基因的最少次数，不能变异成功返回-1。`0 <= bank.length <= 10`

### 方法

- 采用BFS求最少次数，对基金的每个位置进行四种字符的变异，并保证变异基因在基因库中，一旦搜索到终止基因即停止。
- 设置已访问数组防止重复遍历（也可以直接在基因库中抹除）。终止基因一定要保证在基因库中，否则不能有效变异。
- 加入队列前进行判断，可提升搜索效率。
- `bank`的数量较少，转换为set有hash overhead的问题，会较慢，查找可直接用数组。
  - `find(bank.begin(),bank.end(),gene) != bank.end()`
- 设基因长度为n，可变异种类为m，则共有m^n种基因。设`B = bank.length`，基因数组转换为set需要时间为O(nB)，空间为O(nB)
  - 时间复杂度为O(nB + m^n * nm * n)，m^n种基因，内层循环为mn，字符串操作为n。本例中n=8, m=4均为常数，因此时间为O(B)。
  - 空间复杂度为O(nB + m^n)，本例中为O(B)

```cpp
class Solution {
public:
    int minMutation(string startGene, string endGene, vector<string>& bank) {
        if (startGene == endGene) return 0;
        unordered_set<string> bankSet(bank.begin(), bank.end());
        if (bankSet.find(endGene) == bankSet.end()) return -1;
        queue<string> que;
        que.push(startGene);
        int step = 1;
        while (!que.empty()) {
            int size = que.size();
            while (size--) {
                string gene = que.front();
                que.pop();
                for (int i = 0; i < gene.size(); i++) {
                    char oldCode = gene[i];
                    for (char c : "ACGT") {
                        if (oldCode == c) continue;
                        gene[i] = c;
                        if (gene == endGene) return step;
                        if (bankSet.find(gene) != bankSet.end()) {
                            que.push(gene);
                            bankSet.erase(gene);
                        }
                    }
                    gene[i] = oldCode;
                }
            }
            step++;
        }
        return -1;
    }
};
```

## 0443. String Compression

> :orange_circle:

压缩给定的字符数组：连续重复字符视为一组，若该组的长度为1则只添加字符，其它情况添加字符以及重复长度（多位数需拆开）。将结果字符串写回原数组，返回结果的长度。使用常量空间

### 方法

- 双指针，一个指针遍历字符数组找到重复字符及数量，一个指针写回原数组。T: O(n), S: O(1)

```cpp
class Solution {
public:
    int compress(vector<char>& chars) {
        int id = 0, i = 0, n = chars.size();
        while (i < n) {
            char c = chars[i];
            int cnt = 0;
            while (i < n && chars[i] == c) {
                cnt++;
                i++;
            }
            chars[id++] = c;
            if (cnt == 1) continue;
            for (char& s : to_string(cnt)) {
                chars[id++] = s;
            }
        }
        return id;
    }
};
```

## 0446. Arithmetic Slices II - Subsequence

> :red_circle:

给一个整数数组，返回所有的算术子序列的个数。算术子序列：至少三个元素的子序列，且相邻两个元素之间的差值相等

### 方法

- DFS搜索，得到满足条件的算术子序列个数，实为暴力搜索，T: O(2^n), S: O(n)
- 动态规划，`dp[i][d]`表示以`nums[i]`结尾，插值为`d`的弱算术子序列的个数（元素数>=2）。T: O(n^2), S: O(n^2)

```cpp
#define LL long long
class Solution {
public:
    int numberOfArithmeticSlices(vector<int>& nums) {
        int n = nums.size();
        LL ans = 0;
        vector<map<LL, int>> cnt(n);
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < i; j++) {
                LL delta = (LL)nums[i] - (LL)nums[j];
                int sum = 0;
                if (cnt[j].find(delta) != cnt[j].end()) {
                    sum = cnt[j][delta];
                }
                cnt[i][delta] += sum + 1;
                ans += sum;
            }
        }
        return (int)ans;
    }
};
```

## 0451. Sort Characters By Frequency

> :orange_circle:

给一个包含大小写字母和数字的字符串，将字符串按照字符的出现频率排序。`1 <= s.length <= 5 * 10^5`

### 方法一

- 数组哈希，统计字符的频率，并根据频率对index排序，然后得到字符串。T: O(N + KlogK), S: O(N), `N=s.length, K=128 `
- 字符串添加多个字符：`res.append(num, char);  // res += string(num, char);`

```cpp
class Solution {
public:
    string frequencySort(string s) {
        int cnt[128] = {0};
        for (char c : s) cnt[c]++;
        
        vector<int> ids(128);
        for (int i = 0; i < 128; i++) ids[i] = i;
        sort(ids.begin(), ids.end(), [cnt](int i1, int i2) {
            return cnt[i1] > cnt[i2];
        });
        
        string res;
        for (int id : ids) {
            if (cnt[id] == 0) break;
            res.append(cnt[id], id);  // res += string(cnt[id], id);
        }
        return res;
    }
};
```

### 方法二

- Counter & Bucket Sort 字符的频率值在[0, n]范围内，可以使用桶排序，O(N)得到结果。T: O(N), S: O(N)
- 实际运行中，该方法需要两次O(N)遍历，慢于方法一，且空间使用更大

```cpp
class Solution {
public:
    string frequencySort(string s) {
        int n = s.size();
        unordered_map<char, int> cnt;
        for (char c : s) cnt[c]++;

        vector<vector<char>> bucket(n + 1);
        for (auto [c, f] : cnt) {
            bucket[f].push_back(c);
        }

        string res;
        for (int freq = n; freq >= 1; freq--) {
            for (char c : bucket[freq]) {
                res.append(freq, c);
            }
        }
        return res;
    }
};
```

### 拓展

- C++ 11 Lambda表达式方便定义和创建匿名函数。

```cpp
  完整声明格式: 
  [capture list] (params list) mutable exception -> return type { function body } 
  capture list：捕获外部变量列表
      params list：形参列表
      mutable指示符：用来说用是否可以修改捕获的变量
      exception：异常设定
      return type：返回类型
      function body：函数体
      常用格式: 
  [capture list] (params list) -> return type {function body}
  [capture list] (params list) {function body} //省略返回值类型，编译器自动推断：return语句或者void
  [capture list] {function body} 
  外部变量捕获方式：
      - 值捕获[a]，引用捕获[&a]，隐式捕获（编译器自动推断捕获哪些变量，[=]值，[&]引用）
      - []不捕获任何变量，[=]值捕获所有外部变量，[&]引用捕获所有外部变量
```

## 0472. Concatenated Words

> :red_circle:

给一个没有重复的字符串数组，返回所有拼接的单词

### 方法

- 动态规划，将单词表转换为字典，`dp[i]`表示单词的子串[0,i)是拼接单词，遍历`0=<j<i`判断是否由前缀+后缀组成。
- 单词表长度为N，单词长度最长为M。转换为dict为O(NM)，T: O(N*M^3)，S: O(NM)

```cpp
class Solution {
public:
    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {
        unordered_set<string> dict(words.begin(), words.end());
        vector<string> ans;
        for (string w : words) {
            int size = w.size();
            vector<bool> dp(size + 1);
            dp[0] = true;
            for (int i = 1; i <= size; i++) {
                for (int j = (i == size) ? 1 : 0; !dp[i] && j < i; j++) {
                    dp[i] = dp[j] && dict.count(w.substr(j, i - j));
                }
            }
            if (dp[size]) ans.push_back(w);
        }
        return ans;
    }
};
```

## 0491. Non-decreasing Subsequences

> :orange_circle:

整数数组，返回所有不同的非减子序列（至少两个元素）。`1 <= nums.length <= 15; -100 <= nums[i] <= 100`

### 方法

- 回溯搜索，同一个位置的元素要进行去重，使用集合或者哈希数组

```cpp
class Solution {
public:
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        res.clear();
        path.clear();
        backtracking(nums, 0);
        return res;
    }

private:
    vector<vector<int>> res;
    vector<int> path;
    void backtracking(vector<int>& nums, int startIndex) {
        if (path.size() >= 2) {
            res.push_back(path);
        }
        // unordered_set<int> set;
        int used[201] = {0};
        for (int i = startIndex; i < nums.size(); i++) {
            if (!path.empty() && nums[i] < path.back()) continue;
            // if (set.find(nums[i]) != set.end()) continue;
            // set.insert(nums[i]);
            if (used[nums[i] + 100] == 1) continue;
            used[nums[i] + 100] = 1;
            path.push_back(nums[i]);
            backtracking(nums, i + 1);
            path.pop_back();
        }
    }
};
```
