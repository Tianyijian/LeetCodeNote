# LeetCode 0~1000

## 0002. Add Two Numbers

> :orange_circle:

给两个非空链表，代表两个非负整数。数字逆序存储在链表上，每个节点存储一位。将两个数字相加，并返回新的链表

### 方法

- 两个指针遍历两个链表，将每一位相加，注意有进位的情况。进位可以直接`addNext = sum / 10`得到
- 可以建立新链表存储值，也可以直接加在原有的链表上。可以先遍历得到两个链表的长度，也可以不提前遍历
- 不提前计算长度时，两个链表都需要更新数值，谁有加谁，最后返回剩余的即可。T: O(max(m, n)), S: O(1)
- 为了知道最后留下的链表，遍历时条件为`p && p->next`。长度相等，最后各剩一个；长度不同，剩下长的最后一个

```cpp
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode *p1 = l1, *p2 = l2;
        int sum = 0, addNext = 0;
        while ((p1 && p1->next) || (p2 && p2->next)) {
            sum = addNext;
            if (p1) sum += p1->val;
            if (p2) sum += p2->val;
            if (sum > 9) {
                sum = sum % 10;
                addNext = 1;
            } else addNext = 0;
            if (p1) {
                p1->val = sum;
                p1 = p1->next;
            }
            if (p2) {
                p2->val = sum;
                p2 = p2->next;
            }
        }
        if (p1) {
            p1->val += addNext;
            if (p2) p1->val += p2->val;
            if (p1->val > 9) {
                p1->val %= 10;
                p1->next = new ListNode(1);
            }
            return l1;
        } else {
            p2->val += addNext;
            if (p2->val > 9) {
                p2->val %= 10;
                p2->next = new ListNode(1);
            }
            return l2;
        }
    }
};
```

## 0004. Median of Two Sorted Arrays

> :red_circle:

给定两个有序数组，求中位数，要求O(log(m+n))

### 方法

- 二分查找有序数组为O(logn)，利用二分定位中位数的位置
- 利用二分分割较短的数组，根据总长度分割长数组，依据左侧与右侧的大小，移动分割位置。T: O(log(min(m, n))), S: O(1)
- 参考：https://www.youtube.com/watch?v=LPFhl65R7ww

```cpp
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int M = nums1.size(), N = nums2.size();
        if (M > N) return findMedianSortedArrays(nums2, nums1);

        int l = 0, r = M;
        while (l <= r) {
            int partition1 = ((size_t)l + r) / 2;
            int partition2 = (M + N + 1) / 2 - partition1;

            int max1_left = partition1 != 0 ? nums1[partition1 - 1] : INT_MIN;
            int max2_left = partition2 != 0 ? nums2[partition2 - 1] : INT_MIN;

            int min1_right = partition1 != M ? nums1[partition1] : INT_MAX;
            int min2_right = partition2 != N ? nums2[partition2] : INT_MAX;

            if (max1_left <= min2_right && max2_left <= min1_right) {
                int max_left = max(max1_left, max2_left);
                int min_right = min(min1_right, min2_right);
                return (M + N) % 2 ? max_left : (max_left + min_right) / 2.0;
            }

            if (max2_left > min1_right) {
                l = partition1 + 1;
            } else {
                r = partition1 - 1;
            }
        }
        return -1;
    }
};
```

## 0008. String to Integer (atoi)

> :orange_circle:

将字符串转化为整数，读入顺序为空格，正负号，数字，数值溢出时保留在[-2^31, 2^31-1]

### 方法

- 要以正确的顺序读入，如一但开始读入数字，则空格，符号就停止读入，如`“  4+2”`
- 数值可能非常大，判断有溢出时可以立即停止读入，[-2147483648, 2147483647]，如示例`“2000000000000”`
- 写法一：利用for循环遍历数组，判断当前字符能否读入，并进行处理
- 写法二：记录读入的下标，while循环进行处理

<!-- tabs:start -->

####**First**

```cpp
class Solution {
public:
    int myAtoi(string s) {
        bool canReadSpace = true;
        bool canReadSign = true;
        bool neg = false;
        long num = 0;
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == ' '){
                if (!canReadSpace) break;
            } else if (s[i] == '-' || s[i] == '+') {
                if (!canReadSign) break;
                canReadSpace = false;
                canReadSign = false;
                if (s[i] == '-') neg = true;
            } else if (s[i] >= '0' && s[i] <= '9') {
                canReadSign = false;
                canReadSpace = false;
                num = num * 10 + (s[i] - '0');
                if (num - 1 > INT32_MAX) break;
            } else {
                break;
            }
        }
        if (neg) num = -num;
        if (num > INT32_MAX) num = INT32_MAX;
        if (num < INT32_MIN) num = INT32_MIN;
        return (int)num;
    }
};
```

####**Second**

```cpp
class Solution {
public:
    int myAtoi(string s) {
        int sign = 1, num = 0, i = 0;
        while (s[i] == ' ') i++;
        if (s[i] == '-' || s[i] == '+') {
            sign = (s[i] == '-') ? -1 : 1;
            i++;
        }
        while (s[i] >= '0' && s[i] <= '9') {
            if (num > INT_MAX / 10 || (num == INT_MAX / 10 && s[i] - '0' > 7)) {
                if (sign == 1) return INT_MAX;
                else return INT_MIN;
            }
            num = num * 10 + (s[i] - '0');
            i++;
        }
        return sign * num;
    }
};
```

<!-- tabs:end -->

## 0009. Palindrome Number

> :green_circle:

给一个整数x，判断是否回文。如`121`是，而`10, -121`不是。`-2^31 <= x <= 2^31 - 1`

### 方法一

- 将其转为字符串，双指针从两侧向中间扫描判断

```cpp
class Solution {
public:
    bool isPalindrome(int x) {
        string s = to_string(x);
        int left = 0, right = s.size() - 1;
        while (left < right) {
            if (s[left++] != s[right--]) return false;
        }
        return true;
    }
};
```

### 方法二

- Follow up：不转换为字符串。负数不是回文，将数字的每一位取出来，然后双指针判断

```cpp
class Solution {
public:
    bool isPalindrome(int x) {
        if (x < 0) return false;
        vector<int> nums;
        while (x) {
            nums.push_back(x % 10);
            x = x / 10;
        }
        int left = 0, right = nums.size() - 1;
        while (left < right) {
            if (nums[left++] != nums[right--]) return false;
        }
        return true;
    }
};
```

### 方法三

- 将整个数字反转，比较与其本身是否相等。但可能会有超过INT_MAX溢出的情况
- 考虑将数字的一半反转。T: O(log10(*n*)), S: O(1)

```cpp
class Solution {
public:
    bool isPalindrome(int x) {
        if (x < 0 || (x != 0 && x % 10 == 0)) return false;
        int reverseNum = 0;
        while (x > reverseNum) {
            reverseNum = reverseNum * 10 + x % 10;
            x = x / 10;
        }
        return x == reverseNum || x == reverseNum / 10;
    }
};
```

## 0013. Roman to Integer

> :green_circle:

将罗马数字转换为整数。罗马数字共有7个符号，从左到右值最大到最小。当左侧值小于右侧值时，左侧值是被减去的

### 方法

- 记录结果，从左至右扫描，遇到当前符号小于右侧符号的，结果减去当前数，否则加上当前数。T: O(n), S: O(1)

```cpp
class Solution {
public:
    int romanToInt(string s) {
        unordered_map<char, int> map = {{'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, {'C', 100}, {'D', 500}, {'M', 1000}};
        int res = 0;
        for (int i = 0; i < s.size() - 1; i++) {
            if (map[s[i]] < map[s[i + 1]]) {
                res -= map[s[i]];
            } else res += map[s[i]];
        }
        res += map[s.back()];
        return res;
    }
};
```

## 0020. Valid Parentheses

> :green_circle:

给定字符串包含`{, [, (, ), ], }`，判断是否有效。

### 方法

- 字符串模拟栈的操作，栈中添加左括号对应的右括号

```cpp
class Solution {
public:
    bool isValid(string s) {
        if (s.size() % 2 != 0) return false;
        string st;
        for (char c : s) {
            if (c == st.back()) st.pop_back();
            else if (c == '(') st.push_back(')');
            else if (c == '[') st.push_back(']');
            else if (c == '{') st.push_back('}');
            else return false;
        }
        return st.size() == 0;
    }
};
```

## 0022. Generate Parentheses

> :orange_circle:

给n对括号，生成所有的格式良好的括号组合

### 方法

- 回溯，递归记录遍历的路径，按照一定条件添加可以选择的括号
- 写法一：记录剩余的左括号与右括号的数量，相等时必选左括号，左括号数量少时两者都可选择
- 写法二：记录剩余的左括号与右括号的数量，有左括号即可选择，剩余右括号多于左括号时可以选择
- T: O(4^n/n), S: O(4^n/n)

<!-- tabs:start -->

####**First**

```cpp
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        res.clear();
        path = "";
        backtracking(n, n);
        return res;
    }
private:
    vector<string> res;
    string path;
    void backtracking(int left, int right) {
        if (left < 0 || right < 0) return;
        if (left == 0 && right == 0) {
            res.push_back(path);
            return;
        }
        if (left == right) {
            path += "(";
            backtracking(left - 1, right);
            path.pop_back();
        } else {
            for (int i = 0; i < 2; i++) {
                if (i == 0) path += "(";
                else path += ")";
                backtracking(left - 1 + i, right - i);
                path.pop_back();
            }
        }
    }
};
```

####**Second**

```cpp
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        res.clear();
        path = "";
        backtracking(n, n);
        return res;
    }
private:
    vector<string> res;
    string path;
    void backtracking(int left, int right) {
        if (left == 0 && right == 0) {
            res.push_back(path);
            return;
        }
        if (left > 0) {
            path += "(";
            backtracking(left - 1, right);
            path.pop_back();
        } 
        if (right > left)  {
            path += ")";
            backtracking(left, right - 1);
            path.pop_back();
        }
    }
};
```

<!-- tabs:end -->

## 0032. Longest Valid Parentheses

> :red_circle:

给定一个字符串，仅包含`(,)`，找到最长的括号有效的子串，返回其长度

### 方法

- 暴力搜索：两层循环找到每个子串，再判断子串有效性。T: O(n^3), S: O(n)
- 动态规划：`dp[i][j]`是否是括号有效的子串，记录最长的长度，T: O(n^2), S: O(n^2)
- 动态规划2：`dp[i]`是以i结尾的最长有效子串的长度。T: O(n), S: O(n)
- 采用栈，栈中记录下标，每次可以括号消除时，计算栈顶到当前的距离，更新最大长度。注意空栈。T: O(n), S: O(n)

```cpp
class Solution {
public:
    int longestValidParentheses(string s) {
        stack<int> st;
        int res = 0;
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == ')' && st.size()) {
                if (s[st.top()] == '(') {
                    st.pop();
                    int j = st.size() ? st.top() : -1;
                    res = max(res, i - j);
                    continue;
                }
            } 
            st.push(i);
        }
        return res;
    }
};
```

## 0033. Search in Rotated Sorted Array

> :orange_circle:

一维升序数组，可能进行部分旋转后，在其中搜索某个元素位置，O(logn)实现

### 方法

- 二分查找升序数组为O(logn)，旋转数组可以通过局部及整体reverse实现
- 选择一个点将数组分割，其中一部分一定有序，根据mid判断mid在有序部分还是无序部分：
  - mid<left，在右边有序部分，mid>=left，在左边有序部分（注意等号）

- 比较target与有序部分的边界关系，舍弃另一部分
  - 如mid在右侧有序部分[mid, right]，若target>=mid && target<=end，则target在右侧有序部分，舍弃左边部分（start=mid+1）


```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) return mid;
            if (nums[left] <= nums[mid]) {  //[left,mid]有序
                if (nums[left] <= target && nums[mid] >= target) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            } else {						//[mid,right]有序
                if (nums[mid] <= target && nums[right] >= target) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
        }
        return -1;
    }
};
```

## 0036. Valid Sudoku

> :orange_circle:

给定一个`9x9`的数独，判断数独是否有效。每行，每列，及每个`3x3`的格子内，不能有重复的1~9数字

### 方法

- 判断是否有数字重复，可以采用数组哈希。对行、列、格子都建立查重数组，可以一遍遍历。T: O(n^2), S: O(n^2)
- 对于格子，关键在于根据二维下标`i, j`转换为查重数组的一维下标`k = i / 3 * 3 + j / 3`

```cpp
class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        int rowUsed[9][9] = {0}, colUsed[9][9] = {0}, boxUsed[9][9] = {0}; 
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                if (board[i][j] != '.') {
                    int num = board[i][j] - '0' - 1;
                    int k = i / 3 * 3 + j / 3;
                    if (rowUsed[i][num] || colUsed[j][num] || boxUsed[k][num]) return false;
                    rowUsed[i][num] = colUsed[j][num] = boxUsed[k][num] = 1;
                }
            }
        }
        return true;
    }
};
```

## 0041. First Missing Positive

> :red_circle:

给定一个没有排序的整数数组，返回最小的缺失的正整数。O(n)并且常数空间

### 方法一

- 最终答案在[1, n + 1]，把所有的元素放置在相应的位置，忽略大于n或者小于等于0的
- 比如3放置在第三个位置，`[3,1,-4,7] -> [-4,1,3,7] -> [1,-4,3,7]  `，最终`nums[1] != 2`，返回2。T: O(n), S: O(1)

```cpp
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int n = nums.size(); 
        for (int i = 0; i < n; i++) {
            while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {
                swap(nums[i], nums[nums[i] - 1]);
            }       
        }
        for (int i = 0; i < n; i++) {
            if (nums[i] != i + 1) return i + 1;
        }
        return n + 1;
    }
};
```

### 方法二

- `1 <= nums.length <= 100000`，因此最多填满[1, n]。可以用数组哈希，设立数组长度为100005或者n + 1即可
- 该方法空间使用不符合要求。T: O(n), S: O(n)

```cpp
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int hash[100005] = {0};
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] > 0 && nums[i] < 100005) {
                hash[nums[i]] = 1;
            }
        }
        for (int i = 1; i < 100005; i++) {
            if (hash[i] == 0) return i;
        }
        return 0;
    }
};
```

## 0043. Multiply Strings

> :orange_circle:

给两个字符串形式的非负整数，计算两个数的乘积，返回字符串形式的结果。不能使用内置的大数库以及直接将输入转换为整数。`1 <= num1.length, num2.length <= 200`

### 方法

- 字符串最多有200位，不能直接转换为整数计算。模拟两个数的竖式乘法，考虑按位计算，m位数与n位数的乘积最多有`m+n`位
- 直接使用`m+n`位的字符串存储结果。按位计算时，确认结果的存储位置，处理进位的情况。T: O(m*n), S: O(m+n)

<!-- tabs:start -->

####**First**

```cpp
class Solution {
public:
    string multiply(string num1, string num2) {
        if (num1 == "0" || num2 == "0") return "0";
        int m = num1.size(), n = num2.size();
        string ans(m + n, '0');
        for (int i = m - 1; i >= 0; i--) {
            for (int j = n - 1; j >= 0; j--) {
                int k = (m - 1 - i) + (n - 1 - j);
                int val = (num1[i] - '0') * (num2[j] - '0');
                val += (ans[k] - '0');
                ans[k] = val % 10 + '0';
                ans[k + 1] += val / 10;
            }
        }
        while (ans.back() == '0') ans.pop_back();
        reverse(ans.begin(), ans.end());
        return ans;
    }
};
```

####**Second**

```cpp
class Solution {
public:
    string multiply(string num1, string num2) {
        if (num1 == "0" || num2 == "0") return "0";
        int m = num1.size(), n = num2.size();
        string ans(m + n, '0');
        for (int i = m - 1; i >= 0; i--) {
            for (int j = n - 1; j >= 0; j--) {
                int val = (num1[i] - '0') * (num2[j] - '0') + (ans[i + j + 1] - '0');
                ans[i + j + 1] = val % 10 + '0';
                ans[i + j] += val / 10;
            }
        }
        for (int i = 0; i < m + n; i++) {
            if (ans[i] != '0') return ans.substr(i);
        }
        return "0";
    }
};
```

<!-- tabs:end -->

## 0048. Rotate Image

> :orange_circle:

二维矩阵，顺时针旋转90度。要求in-place操作。

### 方法

- 写法一：可以直接元素交换，1与2交换，3与4交换，1与3交换，注意循环不变量
- 写法二：存一个临时元素，直接移动到位置即可

<!-- tabs:start -->

####**First**

```cpp
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        int cicle = (n + 1) / 2;
        for (int j = 0; j < cicle; j++) {
            int last = n - 1 - j;
            for (int i = j; i < last; i++) {
                swap(matrix[j][i], matrix[i][last]);
                swap(matrix[last][n - 1 - i], matrix[n - 1 - i][j]);
            }
            for (int i = j; i < last; i++) {
                swap(matrix[j][i], matrix[last][n - 1 - i]);
            }
        }
    }
};
```

####**Second**

```cpp
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        for (int i = 0; i < (n + 1) / 2; i ++) {
            for (int j = 0; j < n / 2; j++) {
                int temp = matrix[n - 1 - j][i];
                matrix[n - 1 - j][i] = matrix[n - 1 - i][n - j - 1];
                matrix[n - 1 - i][n - j - 1] = matrix[j][n - 1 -i];
                matrix[j][n - 1 - i] = matrix[i][j];
                matrix[i][j] = temp;
            }
        }
    }
};
```

<!-- tabs:end -->

## 0058. Length of Last Word

> :green_circle:

给定字符串，由单词和字符串组成，返回最后一个单词的长度

### 方法

- 从后向前扫描，先跳过起始的空格，记录非空格的长度，再遇到空格时终止

```cpp
class Solution {
public:
    int lengthOfLastWord(string s) {
        int len = 0;
        for (int i = s.size() - 1; i >= 0; i--) {
            if (s[i] == ' ' && len == 0) continue;
            if (s[i] == ' ') break;
            len++;
        }
        return len;
    }
};
```

## 0079. Word Search

> :orange_circle:

给一个二维格子和字符串，判断字符串是否在二维格子中出现

### 方法

- 二维格子的DFS搜索。从每个格子出发，向四周进行搜索，一旦匹配全部字符串，立即返回true停止搜索。T: O(mn), S: O(mn)
- visited数组记录当前路径已经访问过的点，防止重复访问，通过直接设置`board[i][j]='*'`更节省空间
- 在进入每次搜索之前进行条件判断，是否满足要求，可以更早结束搜索，对BFS尤其优化明显

```cpp
class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        int m = board.size(), n = board[0].size();
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                visited = vector<vector<bool>>(m, vector<bool>(n, false));
                visited[i][j] = true;
                if (search(board, word, 0, i, j)) return true;
            }
        }
        return false;
    }
private:
    vector<vector<bool>> visited;
    int direc[5] = {1, 0, -1, 0, 1}; 
    bool search(vector<vector<char>>& board, string word, int step, int row, int col) {
        if (board[row][col] != word[step]) return false;
        if (step == word.size() - 1) return true;

        for (int i = 0; i < 4; i++) {
            int newRow = row + direc[i], newCol = col + direc[i + 1];
            if (newRow < 0 || newCol < 0 || newRow >= board.size() || newCol >= board[0].size()) continue;
            if (visited[newRow][newCol]) continue;
            visited[newRow][newCol] = true;
            if (search(board, word, step + 1, newRow, newCol)) return true;
            visited[newRow][newCol] = false;
        }
        return false;
    }
};
```

## 0088. Merge Sorted Array

> :green_circle:

给定两个非减数组nums1和nums2，元素数为m和n。将其合并为一个有序数组，并保存到nums1中，nums1的长度为m+n

### 方法

- nums1后部分有n个0，因此可以逆序合并，从数组的最右侧开始。最后nums2有剩余，则复制到nums1中。T: O(m + n), S: O(1)

```cpp
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int p1 = m - 1, p2 = n - 1;
        int index = m + n - 1;
        while (p1 >= 0 && p2 >= 0) {
            if (nums1[p1] >= nums2[p2]) {
                nums1[index--] = nums1[p1--]; 
            } else {
                nums1[index--] = nums2[p2--]; 
            }
        }
        while (p2 >= 0) nums1[index--] = nums2[p2--];
    }
};
```

## 0103. Binary Tree Zigzag Level Order Traversal

> :orange_circle:

二叉树的锯齿形层序遍历

### 方法一

- 层序遍历，单向队列，将需要逆序的层的数组reverse即可
- 或者根据是否逆序直接插入到正确的数组位置，比reverse性能更好

```cpp
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> res;
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        int layer = 0;
        while (!que.empty()) {
            int size = que.size();
            vector<int> ans(size);
            for (int i = 0; i < size; i++) {
                TreeNode* cur = que.front();
                que.pop();
                if (layer % 2 == 0) ans[i] = cur->val;
                else ans[size - 1 - i] = cur->val;
                if (cur->left) que.push(cur->left);
                if (cur->right) que.push(cur->right);
            }
            layer++;
            res.push_back(ans);
        }
        return res;
    }
};
```

### 方法二

- 层序遍历，方法一并没有真正锯齿形遍历，而只是将结果改变到了正确顺序

- 采用双向队列实现锯齿形遍历

```cpp
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> res;
        deque<TreeNode*> que;
        if (root != NULL) que.push_front(root);
        bool leftToRight = true;
        while (!que.empty()) {
            int size = que.size();
            vector<int> ans(size);
            for (int i = 0; i < size; i++) {
                if (leftToRight) {
                    TreeNode* cur = que.front();
                    que.pop_front();
                    ans[i] = cur->val;
                    if (cur->left) que.push_back(cur->left);
                    if (cur->right) que.push_back(cur->right);
                } else {
                    TreeNode* cur = que.back();
                    que.pop_back();
                    ans[i] = cur->val;
                    if (cur->right) que.push_front(cur->right);
                    if (cur->left) que.push_front(cur->left);
                }
            }
            leftToRight = !leftToRight;
            res.push_back(ans);
        }
        return res;
    }
};
```

## 0168. Excel Sheet Column Title

> :green_circle:

给定一个数字，返回其对应的Excel表的列名称。`1->A,2->B...26->Z,27->AA,28->AB...`

### 方法

- 字母26个，26个一轮，因此对26取余，除以26
- Excel中A从1开始，且27是AA，每次n要减1。`ABZ: n = (A+1) * 26^2 + (B+1) * 26^1 + (Z+1) * 26^0`
- `string.insert(pos, str), string.insert(pos, n, char), string.insert(pos, str, pos1, n)`

```cpp
class Solution {
public:
    string convertToTitle(int columnNumber) {
        string res;
        while (columnNumber) {
            columnNumber--;
            res.insert(0, 1, columnNumber % 26 + 'A');
            columnNumber /= 26;
        }
        return res;
    }
};
```

## 0223. Rectangle Area

> :orange_circle:

在2维平面上，给出两个矩形左下角和右上角的坐标，计算两个矩形覆盖的面积（可能有重叠）

### 方法

- 先计算出两个矩形的面积，再减去重叠部分的面积。根据坐标大小依次定位重叠部分的四个坐标。T: O(1), S: O(1)

```cpp
class Solution {
public:
    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {
        int area = (bx2 - bx1) * (by2 - by1) + (ax2 - ax1) * (ay2 - ay1);
        if (bx1 >= ax2 || bx2 <= ax1 || by2 <= ay1 || by1 >= ay2) return area;
        int cx1, cy1, cx2, cy2;
        cx1 = bx1 > ax1 ? bx1 : ax1;
        cx2 = bx2 > ax2 ? ax2 : bx2;
        cy1 = by1 > ay1 ? by1 : ay1;
        cy2 = by2 > ay2 ? ay2 : by2;
        int overlap = (cx2 - cx1) * (cy2 - cy1);
        return area - overlap;
    }
};
```

## 0224. Basic Calculator

> :red_circle:

字符串代表一个有效的表达式，计算结果。字符串中包含`+ - ( )`和 `' '`

### 方法

- 设置全局的结果和符号，进行逐步计算。使用栈处理括号的情况
- 遇到数字时，取出所有相连的数字，如`23`，然后进行计算。注意先加时可能溢出`num = num * 10 + s[i++] - '0';`
- 遇到左括号时，将当前的值和符号加入栈中保存`3+(1+..`。遇到右括号时，取出栈中保存的数进行计算`() +3`。

```cpp
class Solution {
public:
    int calculate(string s) {
        int sign = 1;
        int res = 0;
        stack<int> st;
        for (int i = 0; i < s.size(); i++) {
            if (isdigit(s[i])) {
                int num = 0;
                while (i < s.size() && isdigit(s[i])) {
                    num = num * 10 + (s[i++] - '0');
                }
                i--;
                res += num * sign;
                sign = 1;
            } else if (s[i] == '+') {
                sign = 1;
            } else if (s[i] == '-') {
                sign = -1;
            } else if (s[i] == '(') {
                st.push(res);
                st.push(sign);
                res = 0;
                sign = 1;
            } else if (s[i] == ')') {
                res *= st.top();
                st.pop();
                res += st.top();
                st.pop();
            }
        }
        return res;
    }
};
```

## 0263. Ugly Number

> :green_Circle:

丑数是正整数，主要因子是2，3，5。1没有主要因子，也是丑数。判断给的数n是否是丑数，`-2^31 <= n <= 2^31 - 1`

### 方法

- 丑数是正数，且因子是固定的数，因此可以将其一直除以因子，最后一定得到1

```cpp
class Solution {
public:
    bool isUgly(int n) {
        while (n) {
            if (n == 1) return true;
            else if (n % 2 == 0) n /= 2;
            else if (n % 3 == 0) n /= 3;
            else if (n % 5 == 0) n /= 5;
            else return false;
        }
        return false;
    }
};
```

## 0264. Ugly Number II

> :orange_circle:

丑数是主要因子为2，3，5的正整数，从1开始。返回第n个丑数，`1 <= n <= 1690`

### 方法一

- 从最小的1开始，每次乘以2，3，5即可得到之后的丑数，但顺序不确定，如`1*5 > 2*2`，且有重复`2*3 = 3*2`
- 为了每次得到最小的丑数，可以使用小顶堆，且堆顶等于之前取出的元素时，有重复。数据较大有溢出，使用long

```cpp
class Solution {
public:
    int nthUglyNumber(int n) {
        priority_queue<long, vector<long>, greater<long>> que;
        que.push(1);
        long res = 0;
        while (n--) {
            while (!que.empty() && res == que.top()) que.pop();
            res = que.top();
            que.pop();
            que.push(res * 2);
            que.push(res * 3);
            que.push(res * 5);
        }
        return res;
    }
};
```

### 方法二

- 动态规划，使用三个指针分别指向要乘以2，3，5的数，dp数组每次取最小值，并更新相应的指针。
- 有重复数时，两个指针都会移动。如`2*3 = 3*2`，此时指针2和3都会移动，可以去重。T: O(n), S: O(n)

```cpp
class Solution {
public:
    int nthUglyNumber(int n) {
        vector<int> dp(n);
        dp[0] = 1;
        int p2 = 0, p3 = 0, p5 = 0;
        for (int i = 1; i < n; i++) {
            dp[i] = min({dp[p2] * 2, dp[p3] * 3, dp[p5] * 5});
            if (dp[i] == dp[p2] * 2) p2++;
            if (dp[i] == dp[p3] * 3) p3++;
            if (dp[i] == dp[p5] * 5) p5++;
        }
        return dp[n - 1];
    }
};
```

## 0268. Missing Number

> :green_circle:

给一个数组包含n个独特的数，范围是[0,n]，找到唯一一个缺失的数。

Follow up: O(1)额外空间，O(n)时间复杂度

### 方法一

- 将数组排序，遍历查找（O(n)）缺失的数。T: O(nlogn), S: O(logn)

```cpp
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] != i) return i;
        }
        return nums.size();
    }
};
```

### 方法二

- 假定数组有序的情况下，可以二分查找（O(logn)）缺失的数。T: O(nlogn), S: O(logn)
- 一定有`nums[mid] >= mid`，大于代表缺失在数组的前半部分，等于代表在后半部分
- 左闭右开区间：`j = nums.size(), while (i < j), j = mid  `，最后`i==j`  ，返回i或j均可
- 左闭右闭区间：`j = nums.size() - 1, while (i <= j), j = mid - 1`，最后`i = j + 1`，要返回i

<!-- tabs:start -->

####**First**

```cpp
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int i = 0, j = nums.size();
        while (i < j) {
            int mid = i + (j - i) / 2;
            if (nums[mid] == mid) i = mid + 1;
			else j = mid;
        }
        return j; // return i;
    }
};
```

####**Second**

```cpp
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int i = 0, j = nums.size() - 1;
        while (i <= j) {
            int mid = i + (j - i) / 2;
            if (nums[mid] == mid) i = mid + 1;
			else j = mid - 1;
        }
        return i;
    }
};
```

<!-- tabs:end -->

### 方法三

- 数组哈希，记录出现的数，遍历找到缺失的数。T: O(n), S: O(n)

```cpp
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int n = nums.size();
        vector<int> hash(n + 1, 0);
        for (int i : nums) hash[i] = 1;
        for (int i = 0; i < n + 1; i++) {
            if (hash[i] == 0) return i;
        }
        return -1;
    }
};
```

### 方法四

- 求和，总和减去数组的和，即为缺失的数。T: O(n), S: O(1)

```cpp
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int n = nums.size();
        int sum = (0 + n) * (n + 1) / 2;
        for (int num : nums) sum -= num;
        return sum;
    }
};
```

### 方法五

- 位操作，异或，有性质`a ^ 0 = a, a ^ a = 0, a ^ b ^ b = a`，将下标`[0, n]`与数值一起异或，最后剩余的即为缺失的数值。T: O(n), S: O(1)

```cpp
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int res = nums.size();
        for (int i = 0; i < nums.size(); i++) {
            res = res ^ i ^ nums[i];
        }
        return res;
    }
};
```

## 0295. Find Median from Data Stream

> :red_circle:

实现中位数寻找类，数据流不断输入整数，实现添加数据和查找中位数方法

### 方法一

- 维护有序数组，添加元素时通过二分查找确定添加位置O(logn)，查找中位数时根据数组大小直接计算O(1)
- （TLE）实际上vector的insert操作是O(n)时间复杂度。添加: O(n), 查找: O(1)，S: O(n)

```cpp
class MedianFinder {
public:
    MedianFinder() {
        
    }
    
    void addNum(int num) {
        int left = 0, right = nums.size() - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < num) left = mid + 1;
            else if (nums[mid] > num) right = mid - 1;
            else {
                nums.insert(nums.begin() + mid, num);
                return;
            }
        }
        nums.insert(nums.begin() + left, num);
    }
    
    double findMedian() {
        int size = nums.size();
        if (size % 2 == 0) return (nums[size / 2] + nums[size / 2 - 1]) / 2.0;
        else return nums[size / 2];
    }
private:
    vector<int> nums;
};
```

### 方法二

- 大顶堆存储一半小数据，小顶堆存储一半大数据，可以O(1)找到中位数。添加O(logn)，查找O(1)，S: O(n)
- 添加数据时需要保证两个堆的大小平衡，偶数时两个堆数量一样，奇数时大顶堆多一个数
- 先将数据加入大顶堆，再把最大的移向小顶堆，如果小顶堆元素多，再移向大顶堆（可以通过更详细的判断进行优化）

<!-- tabs:start -->

####**First**

```cpp
class MedianFinder {
public:
    priority_queue<int> maxHeap;
    priority_queue<int, vector<int>, greater<int>> minHeap; 
    MedianFinder() {
    }
    void addNum(int num) {
        maxHeap.push(num);
        minHeap.push(maxHeap.top());
        maxHeap.pop();
        if (minHeap.size() > maxHeap.size()) {
            maxHeap.push(minHeap.top());
            minHeap.pop();
        }
    }
    double findMedian() {
        if (maxHeap.size() > minHeap.size()) return maxHeap.top();
        else return (maxHeap.top() + minHeap.top()) / 2.0;
    }
};
```

####**Second**

```cpp
class MedianFinder {
public:
    priority_queue<int> maxHeap;
    priority_queue<int, vector<int>, greater<int>> minHeap; 
    MedianFinder() {   
    }
    void addNum(int num) {
        if (maxHeap.size() == 0 || num < maxHeap.top()) {
            maxHeap.push(num);
            if (maxHeap.size() > minHeap.size() + 1) {
                minHeap.push(maxHeap.top());
                maxHeap.pop();
            }
        }
        else {
            minHeap.push(num);
            if (minHeap.size() > maxHeap.size()) {
                maxHeap.push(minHeap.top());
                minHeap.pop();
            }
        } 
    }
    double findMedian() {
        if (maxHeap.size() > minHeap.size()) return maxHeap.top();
        else return (maxHeap.top() + minHeap.top()) / 2.0;
    }
};
```

<!-- tabs:end -->

## 0328. Odd Even Linked List

> :orange_circle:

单链表，将其按照下标的奇偶划分为两组（第一个下标为奇），奇在前偶在后，返回新的链表。要求O(1)空间O(n)时间

### 方法

- 类似拆分链表，分别记录奇数下标链表，与偶数下标链表，最后合并。T: O(n), S: O(1)

```cpp
class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {
        ListNode *oddHead = new ListNode();
        ListNode *evenHead = new ListNode();
        ListNode *p1 = oddHead, *p2 = evenHead;
        int size = 1;
        ListNode *cur = head;
        while (cur) {
            if (size % 2 == 1) {
                p1->next = cur;
                p1 = p1->next;
            } else {
                p2->next = cur;
                p2 = p2->next;
            }
            size++;
            cur = cur->next;
        }
        p2->next = nullptr;
        p1->next = evenHead->next;
        return oddHead->next;
    }
};
```

## 0345. Reverse Vowels of a String

> :green_circle:

给定字符串，将其中的元音字母进行反转。元音字母是`a e i o u`，可能小写或者大写，且多次出现

### 方法

-  双指针，左右指针的元音字母进行交换。T: O(n), S: O(1)

```cpp
class Solution {
public:
    string reverseVowels(string s) {
        int left = 0, right = s.size() - 1;
        unordered_set<char> set({'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'});
        while (left < right) {
            while (left < s.size() && set.find(s[left]) == set.end()) left++;
            while (right >= 0 && set.find(s[right]) == set.end()) right--;
            if (left < right) {
                swap(s[left++], s[right--]);
            }
        }
        return s;
    }
};
```

## 0374. Guess Number Higher or Lower

> :green_circle:

猜数字游戏。1~n中挑选一个数，猜出该数的大小。可以调用guess函数，-1猜的大，1猜的小，0猜对了

### 方法

- 二分查找，每次取中间，根据猜的结果调整左右边界。T: O(logn), S: O(1)

```cpp
class Solution {
public:
    int guessNumber(int n) {
        int left = 0, right = n;
        int mid;
        while (true) {
            mid = left + (right - left) / 2;
            int res = guess(mid);
            if (res == -1) right = mid - 1;
            else if (res == 1) left = mid + 1;
            else break;
        }
        return mid;
    }
};
```

## 0433. Minimum Genetic Mutation

> :orange_circle:

基因字符串长度为8，由`A C G T`四种字符组成。可改变单个字符进行基因变异。给一个起始基因和一个终止基因，以及一个有效基因库`bank`，返回起始基因变异为终止基因的最少次数，不能变异成功返回-1。`0 <= bank.length <= 10`

### 方法

- 采用BFS求最少次数，对基金的每个位置进行四种字符的变异，并保证变异基因在基因库中，一旦搜索到终止基因即停止。
- 设置已访问数组防止重复遍历（也可以直接在基因库中抹除）。终止基因一定要保证在基因库中，否则不能有效变异。
- 加入队列前进行判断，可提升搜索效率。
- `bank`的数量较少，转换为set有hash overhead的问题，会较慢，查找可直接用数组。
  - `find(bank.begin(),bank.end(),gene) != bank.end()`
- 设基因长度为n，可变异种类为m，则共有m^n种基因。设`B = bank.length`，基因数组转换为set需要时间为O(nB)，空间为O(nB)
  - 时间复杂度为O(nB + m^n * nm * n)，m^n种基因，内层循环为mn，字符串操作为n。本例中n=8, m=4均为常数，因此时间为O(B)。
  - 空间复杂度为O(nB + m^n)，本例中为O(B)

```cpp
class Solution {
public:
    int minMutation(string startGene, string endGene, vector<string>& bank) {
        if (startGene == endGene) return 0;
        unordered_set<string> bankSet(bank.begin(), bank.end());
        if (bankSet.find(endGene) == bankSet.end()) return -1;
        queue<string> que;
        que.push(startGene);
        int step = 1;
        while (!que.empty()) {
            int size = que.size();
            while (size--) {
                string gene = que.front();
                que.pop();
                for (int i = 0; i < gene.size(); i++) {
                    char oldCode = gene[i];
                    for (char c : "ACGT") {
                        if (oldCode == c) continue;
                        gene[i] = c;
                        if (gene == endGene) return step;
                        if (bankSet.find(gene) != bankSet.end()) {
                            que.push(gene);
                            bankSet.erase(gene);
                        }
                    }
                    gene[i] = oldCode;
                }
            }
            step++;
        }
        return -1;
    }
};
```

## 0446. Arithmetic Slices II - Subsequence

> :red_circle:

给一个整数数组，返回所有的算术子序列的个数。算术子序列：至少三个元素的子序列，且相邻两个元素之间的差值相等

### 方法

- DFS搜索，得到满足条件的算术子序列个数，实为暴力搜索，T: O(2^n), S: O(n)
- 动态规划，`dp[i][d]`表示以`nums[i]`结尾，插值为`d`的弱算术子序列的个数（元素数>=2）。T: O(n^2), S: O(n^2)

```cpp
#define LL long long
class Solution {
public:
    int numberOfArithmeticSlices(vector<int>& nums) {
        int n = nums.size();
        LL ans = 0;
        vector<map<LL, int>> cnt(n);
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < i; j++) {
                LL delta = (LL)nums[i] - (LL)nums[j];
                int sum = 0;
                if (cnt[j].find(delta) != cnt[j].end()) {
                    sum = cnt[j][delta];
                }
                cnt[i][delta] += sum + 1;
                ans += sum;
            }
        }
        return (int)ans;
    }
};
```

## 0451. Sort Characters By Frequency

> :orange_circle:

给一个包含大小写字母和数字的字符串，将字符串按照字符的出现频率排序。`1 <= s.length <= 5 * 10^5`

### 方法一

- 数组哈希，统计字符的频率，并根据频率对index排序，然后得到字符串。T: O(N + KlogK), S: O(N), `N=s.length, K=128 `
- 字符串添加多个字符：`res.append(num, char);  // res += string(num, char);`

```cpp
class Solution {
public:
    string frequencySort(string s) {
        int cnt[128] = {0};
        for (char c : s) cnt[c]++;
        
        vector<int> ids(128);
        for (int i = 0; i < 128; i++) ids[i] = i;
        sort(ids.begin(), ids.end(), [cnt](int i1, int i2) {
            return cnt[i1] > cnt[i2];
        });
        
        string res;
        for (int id : ids) {
            if (cnt[id] == 0) break;
            res.append(cnt[id], id);  // res += string(cnt[id], id);
        }
        return res;
    }
};
```

### 方法二

- Counter & Bucket Sort 字符的频率值在[0, n]范围内，可以使用桶排序，O(N)得到结果。T: O(N), S: O(N)
- 实际运行中，该方法需要两次O(N)遍历，慢于方法一，且空间使用更大

```cpp
class Solution {
public:
    string frequencySort(string s) {
        int n = s.size();
        unordered_map<char, int> cnt;
        for (char c : s) cnt[c]++;

        vector<vector<char>> bucket(n + 1);
        for (auto [c, f] : cnt) {
            bucket[f].push_back(c);
        }

        string res;
        for (int freq = n; freq >= 1; freq--) {
            for (char c : bucket[freq]) {
                res.append(freq, c);
            }
        }
        return res;
    }
};
```

### 拓展

- C++ 11 Lambda表达式方便定义和创建匿名函数。

```cpp
  完整声明格式: 
  [capture list] (params list) mutable exception -> return type { function body } 
  capture list：捕获外部变量列表
      params list：形参列表
      mutable指示符：用来说用是否可以修改捕获的变量
      exception：异常设定
      return type：返回类型
      function body：函数体
      常用格式: 
  [capture list] (params list) -> return type {function body}
  [capture list] (params list) {function body} //省略返回值类型，编译器自动推断：return语句或者void
  [capture list] {function body} 
  外部变量捕获方式：
      - 值捕获[a]，引用捕获[&a]，隐式捕获（编译器自动推断捕获哪些变量，[=]值，[&]引用）
      - []不捕获任何变量，[=]值捕获所有外部变量，[&]引用捕获所有外部变量
```

## 0587. Erect the Fence

> :red_circle:

二维平面给一组树的坐标，使用最少的绳子将所有的树围起来，返回边界线上的树的坐标。

### 方法

- 凸包（Convex Hull）问题：计算几何，给定空间一堆离散的点，计算包含所有点的凸多边形
- Graham Scan算法：T : O(nlogn), S: O(n)
- Monotone Chain算法：T : O(nlogn), S: O(n)

```cpp
class Solution {
public:
    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {
        int n = trees.size();
        if (n < 4) return trees;
        sort(trees.begin(), trees.end());
        vector<int> vis(n);
        vector<int> stk(n + 10);
        int cnt = 1;
        for (int i = 1; i < n; ++i) {
            while (cnt > 1 && cross(trees[stk[cnt - 1]], trees[stk[cnt - 2]], trees[i]) < 0) vis[stk[--cnt]] = false;
            vis[i] = true;
            stk[cnt++] = i;
        }
        int m = cnt;
        for (int i = n - 1; i >= 0; --i) {
            if (vis[i]) continue;
            while (cnt > m && cross(trees[stk[cnt - 1]], trees[stk[cnt - 2]], trees[i]) < 0) --cnt;
            stk[cnt++] = i;
        }
        vector<vector<int>> ans;
        for (int i = 0; i < cnt - 1; ++i) ans.push_back(trees[stk[i]]);
        return ans;
    }

    int cross(vector<int>& a, vector<int>& b, vector<int>& c) {
        return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0]);
    }
};
```

## 0834. Sum of Distances in Tree

> :red_circle:

n个节点的无向连通树，有n-1条边。返回树中每个节点到其它所有节点的距离的和。`1 <= n <= 3 * 10^4`

### 方法

- 动态规划，DFS。T: O(N), S: O(N)

```cpp
class Solution {
public:
    vector<unordered_set<int>> tree;
    vector<int> res, count;

    vector<int> sumOfDistancesInTree(int n, vector<vector<int>>& edges) {
        tree.resize(n);
        res.assign(n, 0);
        count.assign(n, 1);
        for (auto e : edges) {
            tree[e[0]].insert(e[1]);
            tree[e[1]].insert(e[0]);
        }
        dfs(0, -1);
        dfs2(0, -1);
        return res;

    }

    void dfs(int root, int pre) {
        for (auto i : tree[root]) {
            if (i == pre) continue;
            dfs(i, root);
            count[root] += count[i];
            res[root] += res[i] + count[i];
        }
    }

    void dfs2(int root, int pre) {
        for (auto i : tree[root]) {
            if (i == pre) continue;
            res[i] = res[root] - count[i] + count.size() - count[i];
            dfs2(i, root);
        }
    }
};
```

## 0841. Keys and Rooms

> :orange_circle:

n个房间，每个房间都锁着门并且保存有一串钥匙。从房间`0`出发，判断是否能访问所有房间

### 方法

- BFS，采用队列，记录访问过的房间。每次遇到新房间时，将其钥匙加入队列。T: O(N + K), S: O(N)
- DFS亦可（采用栈）。可以使用集合记录访问过的房间，最后判断集合大小与房间大小

```cpp
class Solution {
public:
    bool canVisitAllRooms(vector<vector<int>>& rooms) {
        vector<bool> visited(rooms.size(), false);
        queue<int> keys;
        keys.push(0);
        while (!keys.empty()) {
            int k = keys.front();
            keys.pop();
            if (!visited[k]) {
                for (int i : rooms[k]) keys.push(i);
                visited[k] = true;
            }
        }
        for (int i = 0; i < visited.size(); i++) {
            if (!visited[i]) return false;
        }
        return true;
    }
};
```

## 0872. Leaf-Similar Trees

二叉树的叶节点序列是从左到右的叶节点的值构成的序列，判断两个二叉树的叶节点序列是否相同

### 方法

- 遍历二叉树，得到叶节点序列，判断是否相同即可（前序中序后序都可，均能保证叶节点从左到右）。T: O(T1+T2), S: O(T1+T2)

```cpp
class Solution {
public:
    bool leafSimilar(TreeNode* root1, TreeNode* root2) {
        vector<int> leaves1;
        traversal(root1, leaves1);
        vector<int> leaves2;
        traversal(root2, leaves2);
        return leaves1 == leaves2;
    }
private:
    void traversal(TreeNode* root, vector<int>& leaf) {
        if (root->left == nullptr && root->right == nullptr) {
            leaf.push_back(root->val);
        }
        if (root->left) traversal(root->left, leaf);
        if (root->right) traversal(root->right, leaf);
    }
};
```

## 0886. Possible Bipartition

> :orange_circle:

n个人（标签1到n），数组 `dislikes`，其中 `dislikes[i] = [ai, bi]`代表两者互不喜欢。不喜欢的不能在同一组，判断所有的人能否分为两组

### 方法

- 并查集。用图表示关系，每个节点与其相邻节点不在同一个集合里，相邻节点加入同一集合。T: O(N+E), S: O(N + E)
- 注意，在一个图的连通分量中，利用并查集联合任一节点的每个相邻节点，最多得到两个集合。

```cpp
class UnionFind {
    vector<int> parent;
public:
    UnionFind(int n) {
        parent.resize(n);
        for (int i = 0; i < n; i++) parent[i] = i;
    }

    int find(int x) {
        if (parent[x] != x) parent[x] = find(parent[x]);
        return parent[x];
    }

    void join(int x, int y) {
        parent[find(x)] = find(y);
    }
};
class Solution {
public:
    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {
        vector<vector<int>> graph(n + 1);
        for (auto& dis : dislikes) {
            graph[dis[0]].push_back(dis[1]);
            graph[dis[1]].push_back(dis[0]);
        }
        UnionFind uf(n + 1);
        for (int i = 1; i <= n; i++) {
            for (int v : graph[i]) {
                if (uf.find(v) == uf.find(i)) return false;
                uf.join(v, graph[i][0]);
            }
        }
        return true;
    }
};
```

## 0899. Orderly Queue

> :red_circle:

给字符串和整数k，可以将字符串的前k个字符中的一个移动到字符串末尾，进行任意次操作后，返回字典序最小的字符串

### 方法

- k>1时，可以通过移动得到任意排列的字符串，因此直接对字符串排序得到最小的。
- k=1时，进行字符串旋转，记录最小的即可。T: O(n^2), S: O(n)

```cpp
class Solution {
public:
    string orderlyQueue(string s, int k) {
        if (k > 1) {
            sort(s.begin(), s.end());
            return s;
        }
        string res = s;
        for (int i = 1; i < s.length(); i++)
            res = min(res, s.substr(i) + s.substr(0, i));
        return res;
    }
};
```

## 0901. Online Stock Span

> :orange_circle:

一维数组，寻找左侧相邻的小于等于自己的元素个数

### 方法一

- 动态规划，dp[i]表示第i天股票的span，dp[i] += dp[j]，j = j - dp[j]，并且第j天的价格小于等于今天价格
- dp[i] 初始化为1，需要存储历史每天的span值以及价格，包括当前天的下标。T: O(1), S: O(n)
- 可以直接初始化数组为最大元素数，也可以使用动态数组

```cpp
class StockSpanner {
public:
    StockSpanner() {
        prices = vector<int>(10001, 0);
        dp = vector<int>(10001, 1);
        index = 0;
    }
    
    int next(int price) {
        int j = index - 1;
        while (j >= 0 && price >= prices[j]) {
            dp[index] += dp[j];
            j -= dp[j]; 
        }
        prices[index] = price;
        int res = dp[index++];
        return res;
    }

private:
    vector<int> prices;
    vector<int> dp;
    int index;
};
```

### 方法二

- 单调栈，寻找左边相邻的小于等于自己的元素个数
- 维护一个单调递减栈（从栈底到栈顶递减），弹出栈顶price小于今天price的元素，并将其span累加到今天的span上，将今天的（price，span）加入栈顶。
- 复杂度分析
  - 尽管有while循环，但只运行n次。每个元素只能离栈一次，有n个元素，每个next操作的均摊代价为 T: O(1)
  - 最坏情况下（所有价格递减），while循环不运行，栈不弹出，栈中n个元素，S: O(n)
  - 该方法相比动态规划减少了空间消耗

```cpp
class StockSpanner {
public:
    StockSpanner() {
    }
    int next(int price) {
        int span = 1;
        while (!stack.empty() && price >= stack.top().first) {
            span += stack.top().second;
            stack.pop();
        }
        stack.push({price, span});
        return span;
    }

private:
    stack<pair<int, int>> stack;
};
```

## 0931. Minimum Falling Path Sum

> :orange_circle:

`nxn`的二维整数矩阵，返回最小的下落路径和。下落路径是从第一行任一元素开始，从下一行的左下、正下、右下再次选择元素，直至降落到最后一行。`1 <= n <= 100; -100 <= matrix[i][j] <= 100`

### 方法

- 动态规划，记录下落到每个位置时的最小值，其是由上一行的值选择而来。T: O(n^2), S: O(n^2)
- 可以直接在原矩阵中修改，节省动态数组的内存
- 简介写法处理数组边界：`dp[row][max(0, col-1)], dp[row][min(n-1, col+1)]`

```cpp
class Solution {
public:
    int minFallingPathSum(vector<vector<int>>& matrix) {
        int n = matrix.size();
        vector<vector<int>> dp(n, vector<int>(n, 0));
        for (int i = 0; i < n; i++) dp[0][i] = matrix[0][i];
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < n; j++) {
                int minVal = min({dp[i - 1][j], dp[i - 1][max(0, j - 1)], dp[i - 1][min(n - 1, j + 1)]});
                dp[i][j] = minVal + matrix[i][j];
            }
        }
        return *min_element(begin(dp[n - 1]), end(dp[n - 1]));
    }
};
```

### 拓展

- min_element, max_element：从容器的范围中选择最小或最大的元素，并返回指向该元素的迭代器

```cpp
std::min_element(iterator start, iterator end, [compare comp]);
std::max_element(iterator start, iterator end, [compare comp]);

vector<int> v;
int a[] = {1,2,3,4,5};
// 求最小值所在的位置下标
min_element(v.begin(), v.end()) - v.begin();
min_element(a, a + 5) - a;

// 求最小值
*min_element(v.begin(), v.end());
*min_element(a, a + 5);
```

## 0938. Range Sum of BST

> :green_circle:

给一个二叉搜索树，计算节点值在`[low, high]`之间的所有节点的值的总和

### 方法

- 可以利用BST有序的特性，只在当前节点值大于low时遍历左节点，节点值小于high时遍历右节点。T: O(N), S: O(N)

```cpp
class Solution {
public:
    int rangeSumBST(TreeNode* root, int low, int high) {
        int res = 0;
        traversal(root, low, high, res);
        return res;
    }
private:
    void traversal(TreeNode* node, int low, int high, int& res) {
        if (node == NULL) return;
        if (node->val >= low && node->val <= high) res += node->val;
        if (node->val > low) traversal(node->left, low, high, res);
        if (node->val < high) traversal(node->right, low, high, res);
    }
};
```

