# LeetCode 0~1000

## 0004. Median of Two Sorted Arrays

> :red_circle:

给定两个有序数组，求中位数，要求O(log(m+n))

### 方法

- 二分查找有序数组为O(logn)，利用二分定位中位数的位置

```

```



## 0022. Generate Parentheses

> :orange_circle:

给n对括号，生成所有的格式良好的括号组合

### 方法

- 回溯，递归记录遍历的路径，按照一定条件添加可以选择的括号
- 写法一：记录剩余的左括号与右括号的数量，相等时必选左括号，左括号数量少时两者都可选择
- 写法二：记录剩余的左括号与右括号的数量，有左括号即可选择，剩余右括号多于左括号时可以选择
- T: O(4^n/n), S: O(4^n/n)

<!-- tabs:start -->

\#### **First**

```cpp
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        res.clear();
        path = "";
        backtracking(n, n);
        return res;
    }
private:
    vector<string> res;
    string path;
    void backtracking(int left, int right) {
        if (left < 0 || right < 0) return;
        if (left == 0 && right == 0) {
            res.push_back(path);
            return;
        }
        if (left == right) {
            path += "(";
            backtracking(left - 1, right);
            path.pop_back();
        } else {
            for (int i = 0; i < 2; i++) {
                if (i == 0) path += "(";
                else path += ")";
                backtracking(left - 1 + i, right - i);
                path.pop_back();
            }
        }
    }
};
```

\#### **Second**

```cpp
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        res.clear();
        path = "";
        backtracking(n, n);
        return res;
    }
private:
    vector<string> res;
    string path;
    void backtracking(int left, int right) {
        if (left == 0 && right == 0) {
            res.push_back(path);
            return;
        }
        if (left > 0) {
            path += "(";
            backtracking(left - 1, right);
            path.pop_back();
        } 
        if (right > left)  {
            path += ")";
            backtracking(left, right - 1);
            path.pop_back();
        }
    }
};
```

<!-- tabs:start -->

## 0033. Search in Rotated Sorted Array

> :orange_circle:

一维升序数组，可能进行部分旋转后，在其中搜索某个元素位置，O(logn)实现

### 方法

- 二分查找升序数组为O(logn)，旋转数组可以通过局部及整体reverse实现
- 选择一个点将数组分割，其中一部分一定有序，根据mid判断mid在有序部分还是无序部分：
  - mid<left，在右边有序部分，mid>=left，在左边有序部分（注意等号）

- 比较target与有序部分的边界关系，舍弃另一部分
  - 如mid在右侧有序部分[mid, right]，若target>=mid && target<=end，则target在右侧有序部分，舍弃左边部分（start=mid+1）


```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) return mid;
            if (nums[left] <= nums[mid]) {  //[left,mid]有序
                if (nums[left] <= target && nums[mid] >= target) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            } else {						//[mid,right]有序
                if (nums[mid] <= target && nums[right] >= target) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
        }
        return -1;
    }
};
```

## 0048. Rotate Image

> :orange_circle:

二维矩阵，顺时针旋转90度。要求in-place操作。

### 方法

- 写法一：可以直接元素交换，1与2交换，3与4交换，1与3交换，注意循环不变量
- 写法二：存一个临时元素，直接移动到位置即可

<!-- tabs:start -->

**First**

```cpp
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        int cicle = (n + 1) / 2;
        for (int j = 0; j < cicle; j++) {
            int last = n - 1 - j;
            for (int i = j; i < last; i++) {
                swap(matrix[j][i], matrix[i][last]);
                swap(matrix[last][n - 1 - i], matrix[n - 1 - i][j]);
            }
            for (int i = j; i < last; i++) {
                swap(matrix[j][i], matrix[last][n - 1 - i]);
            }
        }
    }
};
```

#### **Second**

```cpp
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        for (int i = 0; i < (n + 1) / 2; i ++) {
            for (int j = 0; j < n / 2; j++) {
                int temp = matrix[n - 1 - j][i];
                matrix[n - 1 - j][i] = matrix[n - 1 - i][n - j - 1];
                matrix[n - 1 - i][n - j - 1] = matrix[j][n - 1 -i];
                matrix[j][n - 1 - i] = matrix[i][j];
                matrix[i][j] = temp;
            }
        }
    }
};
```

<!-- tabs:end -->

## 0103. Binary Tree Zigzag Level Order Traversal

> :orange_circle:

二叉树的锯齿形层序遍历

### 方法一

- 层序遍历，单向队列，将需要逆序的层的数组reverse即可
- 或者根据是否逆序直接插入到正确的数组位置，比reverse性能更好

```cpp
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> res;
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        int layer = 0;
        while (!que.empty()) {
            int size = que.size();
            vector<int> ans(size);
            for (int i = 0; i < size; i++) {
                TreeNode* cur = que.front();
                que.pop();
                if (layer % 2 == 0) ans[i] = cur->val;
                else ans[size - 1 - i] = cur->val;
                if (cur->left) que.push(cur->left);
                if (cur->right) que.push(cur->right);
            }
            layer++;
            res.push_back(ans);
        }
        return res;
    }
};
```

### 方法二

- 层序遍历，方法一并没有真正锯齿形遍历，而只是将结果改变到了正确顺序

- 采用双向队列实现锯齿形遍历

```cpp
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> res;
        deque<TreeNode*> que;
        if (root != NULL) que.push_front(root);
        bool leftToRight = true;
        while (!que.empty()) {
            int size = que.size();
            vector<int> ans(size);
            for (int i = 0; i < size; i++) {
                if (leftToRight) {
                    TreeNode* cur = que.front();
                    que.pop_front();
                    ans[i] = cur->val;
                    if (cur->left) que.push_back(cur->left);
                    if (cur->right) que.push_back(cur->right);
                } else {
                    TreeNode* cur = que.back();
                    que.pop_back();
                    ans[i] = cur->val;
                    if (cur->right) que.push_front(cur->right);
                    if (cur->left) que.push_front(cur->left);
                }
            }
            leftToRight = !leftToRight;
            res.push_back(ans);
        }
        return res;
    }
};
```

## 560. Subarray Sum Equals K

> :orange_circle:

给定一维数组和整数k，寻找元素和等于K的子数组，返回子数组数量。数组元素取值[-1000, 1000]

### 方法

- 数组元素有正数负数和0，不能保证滑动窗口移动时的总和大小

## 0901. Online Stock Span

> :orange_circle:

一维数组，寻找左侧相邻的小于等于自己的元素个数

### 方法一

- 动态规划，dp[i]表示第i天股票的span，dp[i] += dp[j]，j = j - dp[j]，并且第j天的价格小于等于今天价格
- dp[i] 初始化为1，需要存储历史每天的span值以及价格，包括当前天的下标。T: O(1), S: O(n)
- 可以直接初始化数组为最大元素数，也可以使用动态数组

```cpp
class StockSpanner {
public:
    StockSpanner() {
        prices = vector<int>(10001, 0);
        dp = vector<int>(10001, 1);
        index = 0;
    }
    
    int next(int price) {
        int j = index - 1;
        while (j >= 0 && price >= prices[j]) {
            dp[index] += dp[j];
            j -= dp[j]; 
        }
        prices[index] = price;
        int res = dp[index++];
        return res;
    }

private:
    vector<int> prices;
    vector<int> dp;
    int index;
};
```

### 方法二

- 单调栈，寻找左边相邻的小于等于自己的元素个数
- 维护一个单调递减栈（从栈底到栈顶递减），弹出栈顶price小于今天price的元素，并将其span累加到今天的span上，将今天的（price，span）加入栈顶。
- 复杂度分析
  - 尽管有while循环，但只运行n次。每个元素只能离栈一次，有n个元素，每个next操作的均摊代价为 T: O(1)
  - 最坏情况下（所有价格递减），while循环不运行，栈不弹出，栈中n个元素，S: O(n)
  - 该方法相比动态规划减少了空间消耗

```cpp
class StockSpanner {
public:
    StockSpanner() {
    }
    int next(int price) {
        int span = 1;
        while (!stack.empty() && price >= stack.top().first) {
            span += stack.top().second;
            stack.pop();
        }
        stack.push({price, span});
        return span;
    }

private:
    stack<pair<int, int>> stack;
};
```

