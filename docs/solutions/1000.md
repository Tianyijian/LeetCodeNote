# LeetCode 0~1000

## 0033. Search in Rotated Sorted Array

> :orange_circle:

一维升序数组，可能进行部分旋转后，在其中搜索某个元素位置，O(logn)实现

### 方法

- 二分查找升序数组为O(logn)，旋转数组可以通过局部及整体reverse实现
- 选择一个点将数组分割，其中一部分一定有序，根据mid判断mid在有序部分还是无序部分：
  - mid<left，在右边有序部分，mid>=left，在左边有序部分（注意等号）

- 比较target与有序部分的边界关系，舍弃另一部分
  - 如mid在右侧有序部分[mid, right]，若target>=mid && target<=end，则target在右侧有序部分，舍弃左边部分（start=mid+1）


```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) return mid;
            if (nums[left] <= nums[mid]) {  //[left,mid]有序
                if (nums[left] <= target && nums[mid] >= target) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            } else {						//[mid,right]有序
                if (nums[mid] <= target && nums[right] >= target) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
        }
        return -1;
    }
};
```



## 0901. Online Stock Span

> :orange_circle:

一维数组，寻找左侧相邻的小于等于自己的元素个数

### 方法一

- 动态规划，dp[i]表示第i天股票的span，dp[i] += dp[j]，j = j - dp[j]，并且第j天的价格小于等于今天价格
- dp[i] 初始化为1，需要存储历史每天的span值以及价格，包括当前天的下标。T: O(1), S: O(n)
- 可以直接初始化数组为最大元素数，也可以使用动态数组

```cpp
class StockSpanner {
public:
    StockSpanner() {
        prices = vector<int>(10001, 0);
        dp = vector<int>(10001, 1);
        index = 0;
    }
    
    int next(int price) {
        int j = index - 1;
        while (j >= 0 && price >= prices[j]) {
            dp[index] += dp[j];
            j -= dp[j]; 
        }
        prices[index] = price;
        int res = dp[index++];
        return res;
    }

private:
    vector<int> prices;
    vector<int> dp;
    int index;
};
```

### 方法二

- 单调栈，寻找左边相邻的小于等于自己的元素个数
- 维护一个单调递减栈（从栈底到栈顶递减），弹出栈顶price小于今天price的元素，并将其span累加到今天的span上，将今天的（price，span）加入栈顶。
- 复杂度分析
  - 尽管有while循环，但只运行n次。每个元素只能离栈一次，有n个元素，每个next操作的均摊代价为 T: O(1)
  - 最坏情况下（所有价格递减），while循环不运行，栈不弹出，栈中n个元素，S: O(n)
  - 该方法相比动态规划减少了空间消耗

```cpp
class StockSpanner {
public:
    StockSpanner() {

    }
    
    int next(int price) {
        int span = 1;
        while (!stack.empty() && price >= stack.top().first) {
            span += stack.top().second;
            stack.pop();
        }
        stack.push({price, span});
        return span;
    }

private:
    stack<pair<int, int>> stack;
};
```

