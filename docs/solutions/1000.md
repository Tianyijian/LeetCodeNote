# LeetCode 0~1000

## 0004. Median of Two Sorted Arrays

> :red_circle:

给定两个有序数组，求中位数，要求O(log(m+n))

### 方法

- 二分查找有序数组为O(logn)，利用二分定位中位数的位置
- 利用二分分割较短的数组，根据总长度分割长数组，依据左侧与右侧的大小，移动分割位置。T: O(log(min(m, n))), S: O(1)
- 参考：https://www.youtube.com/watch?v=LPFhl65R7ww

```cpp
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int M = nums1.size(), N = nums2.size();
        if (M > N) return findMedianSortedArrays(nums2, nums1);

        int l = 0, r = M;
        while (l <= r) {
            int partition1 = ((size_t)l + r) / 2;
            int partition2 = (M + N + 1) / 2 - partition1;

            int max1_left = partition1 != 0 ? nums1[partition1 - 1] : INT_MIN;
            int max2_left = partition2 != 0 ? nums2[partition2 - 1] : INT_MIN;

            int min1_right = partition1 != M ? nums1[partition1] : INT_MAX;
            int min2_right = partition2 != N ? nums2[partition2] : INT_MAX;

            if (max1_left <= min2_right && max2_left <= min1_right) {
                int max_left = max(max1_left, max2_left);
                int min_right = min(min1_right, min2_right);
                return (M + N) % 2 ? max_left : (max_left + min_right) / 2.0;
            }

            if (max2_left > min1_right) {
                l = partition1 + 1;
            } else {
                r = partition1 - 1;
            }
        }
        return -1;
    }
};
```

## 0008. String to Integer (atoi)

> :orange_circle:

将字符串转化为整数，读入顺序为空格，正负号，数字，数值溢出时保留在[-2^31, 2^31-1]

### 方法

- 要以正确的顺序读入，如一但开始读入数字，则空格，符号就停止读入，如`“  4+2”`
- 数值可能非常大，判断有溢出时可以立即停止读入，[-2147483648, 2147483647]，如示例`“2000000000000”`
- 写法一：利用for循环遍历数组，判断当前字符能否读入，并进行处理
- 写法二：记录读入的下标，while循环进行处理

<!-- tabs:start -->

####**First**

```cpp
class Solution {
public:
    int myAtoi(string s) {
        bool canReadSpace = true;
        bool canReadSign = true;
        bool neg = false;
        long num = 0;
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == ' '){
                if (!canReadSpace) break;
            } else if (s[i] == '-' || s[i] == '+') {
                if (!canReadSign) break;
                canReadSpace = false;
                canReadSign = false;
                if (s[i] == '-') neg = true;
            } else if (s[i] >= '0' && s[i] <= '9') {
                canReadSign = false;
                canReadSpace = false;
                num = num * 10 + (s[i] - '0');
                if (num - 1 > INT32_MAX) break;
            } else {
                break;
            }
        }
        if (neg) num = -num;
        if (num > INT32_MAX) num = INT32_MAX;
        if (num < INT32_MIN) num = INT32_MIN;
        return (int)num;
    }
};
```

####**Second**

```cpp
class Solution {
public:
    int myAtoi(string s) {
        int sign = 1, num = 0, i = 0;
        while (s[i] == ' ') i++;
        if (s[i] == '-' || s[i] == '+') {
            sign = (s[i] == '-') ? -1 : 1;
            i++;
        }
        while (s[i] >= '0' && s[i] <= '9') {
            if (num > INT_MAX / 10 || (num == INT_MAX / 10 && s[i] - '0' > 7)) {
                if (sign == 1) return INT_MAX;
                else return INT_MIN;
            }
            num = num * 10 + (s[i] - '0');
            i++;
        }
        return sign * num;
    }
};
```

<!-- tabs:end -->

## 0020. Valid Parentheses

> :green_circle:

给定字符串包含`{, [, (, ), ], }`，判断是否有效。

### 方法

- 字符串模拟栈的操作，栈中添加左括号对应的右括号

```cpp
class Solution {
public:
    bool isValid(string s) {
        if (s.size() % 2 != 0) return false;
        string st;
        for (char c : s) {
            if (c == st.back()) st.pop_back();
            else if (c == '(') st.push_back(')');
            else if (c == '[') st.push_back(']');
            else if (c == '{') st.push_back('}');
            else return false;
        }
        return st.size() == 0;
    }
};
```

## 0022. Generate Parentheses

> :orange_circle:

给n对括号，生成所有的格式良好的括号组合

### 方法

- 回溯，递归记录遍历的路径，按照一定条件添加可以选择的括号
- 写法一：记录剩余的左括号与右括号的数量，相等时必选左括号，左括号数量少时两者都可选择
- 写法二：记录剩余的左括号与右括号的数量，有左括号即可选择，剩余右括号多于左括号时可以选择
- T: O(4^n/n), S: O(4^n/n)

<!-- tabs:start -->

####**First**

```cpp
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        res.clear();
        path = "";
        backtracking(n, n);
        return res;
    }
private:
    vector<string> res;
    string path;
    void backtracking(int left, int right) {
        if (left < 0 || right < 0) return;
        if (left == 0 && right == 0) {
            res.push_back(path);
            return;
        }
        if (left == right) {
            path += "(";
            backtracking(left - 1, right);
            path.pop_back();
        } else {
            for (int i = 0; i < 2; i++) {
                if (i == 0) path += "(";
                else path += ")";
                backtracking(left - 1 + i, right - i);
                path.pop_back();
            }
        }
    }
};
```

####**Second**

```cpp
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        res.clear();
        path = "";
        backtracking(n, n);
        return res;
    }
private:
    vector<string> res;
    string path;
    void backtracking(int left, int right) {
        if (left == 0 && right == 0) {
            res.push_back(path);
            return;
        }
        if (left > 0) {
            path += "(";
            backtracking(left - 1, right);
            path.pop_back();
        } 
        if (right > left)  {
            path += ")";
            backtracking(left, right - 1);
            path.pop_back();
        }
    }
};
```

<!-- tabs:end -->

## 0032. Longest Valid Parentheses

> :red_circle:

给定一个字符串，仅包含`(,)`，找到最长的括号有效的子串，返回其长度

### 方法

- 暴力搜索：两层循环找到每个子串，再判断子串有效性。T: O(n^3), S: O(n)
- 动态规划：`dp[i][j]`是否是括号有效的子串，记录最长的长度，T: O(n^2), S: O(n^2)
- 动态规划2：`dp[i]`是以i结尾的最长有效子串的长度。T: O(n), S: O(n)
- 采用栈，栈中记录下标，每次可以括号消除时，计算栈顶到当前的距离，更新最大长度。注意空栈。T: O(n), S: O(n)

```cpp
class Solution {
public:
    int longestValidParentheses(string s) {
        stack<int> st;
        int res = 0;
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == ')' && st.size()) {
                if (s[st.top()] == '(') {
                    st.pop();
                    int j = st.size() ? st.top() : -1;
                    res = max(res, i - j);
                    continue;
                }
            } 
            st.push(i);
        }
        return res;
    }
};
```

## 0033. Search in Rotated Sorted Array

> :orange_circle:

一维升序数组，可能进行部分旋转后，在其中搜索某个元素位置，O(logn)实现

### 方法

- 二分查找升序数组为O(logn)，旋转数组可以通过局部及整体reverse实现
- 选择一个点将数组分割，其中一部分一定有序，根据mid判断mid在有序部分还是无序部分：
  - mid<left，在右边有序部分，mid>=left，在左边有序部分（注意等号）

- 比较target与有序部分的边界关系，舍弃另一部分
  - 如mid在右侧有序部分[mid, right]，若target>=mid && target<=end，则target在右侧有序部分，舍弃左边部分（start=mid+1）


```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) return mid;
            if (nums[left] <= nums[mid]) {  //[left,mid]有序
                if (nums[left] <= target && nums[mid] >= target) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            } else {						//[mid,right]有序
                if (nums[mid] <= target && nums[right] >= target) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
        }
        return -1;
    }
};
```

## 0041. First Missing Positive

> :red_circle:

给定一个没有排序的整数数组，返回最小的缺失的正整数。O(n)并且常数空间

### 方法

- 最终答案在[1, n + 1]，把所有的元素放置在相应的位置，忽略大于n或者小于等于0的
- 比如3放置在第三个位置，`[3,1,-4,7] -> [-4,1,3,7] -> [1,-4,3,7]  `，最终`nums[1] != 2`，返回2

```cpp
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int n = nums.size(); 
        for (int i = 0; i < n; i++) {
            while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {
                swap(nums[i], nums[nums[i] - 1]);
            }       
        }
        for (int i = 0; i < n; i++) {
            if (nums[i] != i + 1) return i + 1;
        }
        return n + 1;
    }
};
```

## 0048. Rotate Image

> :orange_circle:

二维矩阵，顺时针旋转90度。要求in-place操作。

### 方法

- 写法一：可以直接元素交换，1与2交换，3与4交换，1与3交换，注意循环不变量
- 写法二：存一个临时元素，直接移动到位置即可

<!-- tabs:start -->

####**First**

```cpp
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        int cicle = (n + 1) / 2;
        for (int j = 0; j < cicle; j++) {
            int last = n - 1 - j;
            for (int i = j; i < last; i++) {
                swap(matrix[j][i], matrix[i][last]);
                swap(matrix[last][n - 1 - i], matrix[n - 1 - i][j]);
            }
            for (int i = j; i < last; i++) {
                swap(matrix[j][i], matrix[last][n - 1 - i]);
            }
        }
    }
};
```

####**Second**

```cpp
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        for (int i = 0; i < (n + 1) / 2; i ++) {
            for (int j = 0; j < n / 2; j++) {
                int temp = matrix[n - 1 - j][i];
                matrix[n - 1 - j][i] = matrix[n - 1 - i][n - j - 1];
                matrix[n - 1 - i][n - j - 1] = matrix[j][n - 1 -i];
                matrix[j][n - 1 - i] = matrix[i][j];
                matrix[i][j] = temp;
            }
        }
    }
};
```

<!-- tabs:end -->

## 0103. Binary Tree Zigzag Level Order Traversal

> :orange_circle:

二叉树的锯齿形层序遍历

### 方法一

- 层序遍历，单向队列，将需要逆序的层的数组reverse即可
- 或者根据是否逆序直接插入到正确的数组位置，比reverse性能更好

```cpp
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> res;
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        int layer = 0;
        while (!que.empty()) {
            int size = que.size();
            vector<int> ans(size);
            for (int i = 0; i < size; i++) {
                TreeNode* cur = que.front();
                que.pop();
                if (layer % 2 == 0) ans[i] = cur->val;
                else ans[size - 1 - i] = cur->val;
                if (cur->left) que.push(cur->left);
                if (cur->right) que.push(cur->right);
            }
            layer++;
            res.push_back(ans);
        }
        return res;
    }
};
```

### 方法二

- 层序遍历，方法一并没有真正锯齿形遍历，而只是将结果改变到了正确顺序

- 采用双向队列实现锯齿形遍历

```cpp
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> res;
        deque<TreeNode*> que;
        if (root != NULL) que.push_front(root);
        bool leftToRight = true;
        while (!que.empty()) {
            int size = que.size();
            vector<int> ans(size);
            for (int i = 0; i < size; i++) {
                if (leftToRight) {
                    TreeNode* cur = que.front();
                    que.pop_front();
                    ans[i] = cur->val;
                    if (cur->left) que.push_back(cur->left);
                    if (cur->right) que.push_back(cur->right);
                } else {
                    TreeNode* cur = que.back();
                    que.pop_back();
                    ans[i] = cur->val;
                    if (cur->right) que.push_front(cur->right);
                    if (cur->left) que.push_front(cur->left);
                }
            }
            leftToRight = !leftToRight;
            res.push_back(ans);
        }
        return res;
    }
};
```

## 0295. Find Median from Data Stream

> :red_circle:

实现中位数寻找类，数据流不断输入整数，实现添加数据和查找中位数方法

### 方法一

- 维护有序数组，添加元素时通过二分查找确定添加位置O(logn)，查找中位数时根据数组大小直接计算O(1)
- （TLE）实际上vector的insert操作是O(n)时间复杂度。添加: O(n), 查找: O(1)，S: O(n)

```cpp
class MedianFinder {
public:
    MedianFinder() {
        
    }
    
    void addNum(int num) {
        int left = 0, right = nums.size() - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < num) left = mid + 1;
            else if (nums[mid] > num) right = mid - 1;
            else {
                nums.insert(nums.begin() + mid, num);
                return;
            }
        }
        nums.insert(nums.begin() + left, num);
    }
    
    double findMedian() {
        int size = nums.size();
        if (size % 2 == 0) return (nums[size / 2] + nums[size / 2 - 1]) / 2.0;
        else return nums[size / 2];
    }
private:
    vector<int> nums;
};
```

### 方法二

- 大顶堆存储一半小数据，小顶堆存储一半大数据，可以O(1)找到中位数。添加O(logn)，查找O(1)，S: O(n)
- 添加数据时需要保证两个堆的大小平衡，偶数时两个堆数量一样，奇数时大顶堆多一个数
- 先将数据加入大顶堆，再把最大的移向小顶堆，如果小顶堆元素多，再移向大顶堆（可以通过更详细的判断进行优化）

<!-- tabs:start -->

####**First**

```cpp
class MedianFinder {
public:
    priority_queue<int> maxHeap;
    priority_queue<int, vector<int>, greater<int>> minHeap; 
    MedianFinder() {
    }
    void addNum(int num) {
        maxHeap.push(num);
        minHeap.push(maxHeap.top());
        maxHeap.pop();
        if (minHeap.size() > maxHeap.size()) {
            maxHeap.push(minHeap.top());
            minHeap.pop();
        }
    }
    double findMedian() {
        if (maxHeap.size() > minHeap.size()) return maxHeap.top();
        else return (maxHeap.top() + minHeap.top()) / 2.0;
    }
};
```

####**Second**

```cpp
class MedianFinder {
public:
    priority_queue<int> maxHeap;
    priority_queue<int, vector<int>, greater<int>> minHeap; 
    MedianFinder() {   
    }
    void addNum(int num) {
        if (maxHeap.size() == 0 || num < maxHeap.top()) {
            maxHeap.push(num);
            if (maxHeap.size() > minHeap.size() + 1) {
                minHeap.push(maxHeap.top());
                maxHeap.pop();
            }
        }
        else {
            minHeap.push(num);
            if (minHeap.size() > maxHeap.size()) {
                maxHeap.push(minHeap.top());
                minHeap.pop();
            }
        } 
    }
    double findMedian() {
        if (maxHeap.size() > minHeap.size()) return maxHeap.top();
        else return (maxHeap.top() + minHeap.top()) / 2.0;
    }
};
```

<!-- tabs:end -->

## 0374. Guess Number Higher or Lower

> :green_circle:

猜数字游戏。1~n中挑选一个数，猜出该数的大小。可以调用guess函数，-1猜的大，1猜的小，0猜对了

### 方法

- 二分查找，每次取中间，根据猜的结果调整左右边界。T: O(logn), S: O(1)

```cpp
class Solution {
public:
    int guessNumber(int n) {
        int left = 0, right = n;
        int mid;
        while (true) {
            mid = left + (right - left) / 2;
            int res = guess(mid);
            if (res == -1) right = mid - 1;
            else if (res == 1) left = mid + 1;
            else break;
        }
        return mid;
    }
};
```

## 0901. Online Stock Span

> :orange_circle:

一维数组，寻找左侧相邻的小于等于自己的元素个数

### 方法一

- 动态规划，dp[i]表示第i天股票的span，dp[i] += dp[j]，j = j - dp[j]，并且第j天的价格小于等于今天价格
- dp[i] 初始化为1，需要存储历史每天的span值以及价格，包括当前天的下标。T: O(1), S: O(n)
- 可以直接初始化数组为最大元素数，也可以使用动态数组

```cpp
class StockSpanner {
public:
    StockSpanner() {
        prices = vector<int>(10001, 0);
        dp = vector<int>(10001, 1);
        index = 0;
    }
    
    int next(int price) {
        int j = index - 1;
        while (j >= 0 && price >= prices[j]) {
            dp[index] += dp[j];
            j -= dp[j]; 
        }
        prices[index] = price;
        int res = dp[index++];
        return res;
    }

private:
    vector<int> prices;
    vector<int> dp;
    int index;
};
```

### 方法二

- 单调栈，寻找左边相邻的小于等于自己的元素个数
- 维护一个单调递减栈（从栈底到栈顶递减），弹出栈顶price小于今天price的元素，并将其span累加到今天的span上，将今天的（price，span）加入栈顶。
- 复杂度分析
  - 尽管有while循环，但只运行n次。每个元素只能离栈一次，有n个元素，每个next操作的均摊代价为 T: O(1)
  - 最坏情况下（所有价格递减），while循环不运行，栈不弹出，栈中n个元素，S: O(n)
  - 该方法相比动态规划减少了空间消耗

```cpp
class StockSpanner {
public:
    StockSpanner() {
    }
    int next(int price) {
        int span = 1;
        while (!stack.empty() && price >= stack.top().first) {
            span += stack.top().second;
            stack.pop();
        }
        stack.push({price, span});
        return span;
    }

private:
    stack<pair<int, int>> stack;
};
```

